#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.query2

** Helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn trace [id _] (dorun _) (prn "----") (prn id _) _)

  (defn qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (re-matches #"^\?.*" (name x))))

  (defn make-qvar
    "Creates a new auto-named qvar (symbol)."
    [] (gensym "?__q"))

  (defn resolve-path-pattern
    "Takes a path triple pattern where the predicate is a seq of preds.
    Returns seq of query patterns with injected temp qvars for inbetween
    patterns. E.g.

        [?s [p1 p2 p3] ?o]
        => ([?s p1 ?__q0] [?__q0 p2 ?__q1] [?__q1 p3 ?o])"
    [[s p o]]
    (let [vars (->> make-qvar
                    (repeatedly (dec (count p)))
                    (cons s))]
      (->> (concat (interleave vars p) [o])
           (d/successive-nth 3 2))))

  (defn unique-bindings?
    "Returns true if all values in the given map are unique, i.e.
    no two keys are mapped to the same value."
    [coll] (== (count (set (vals coll))) (count coll)))

  (defn accumulate-result-vars
    "Takes a query result map and returns map of all found qvars
    as keys and their value sets."
    [res]
    (reduce
     (fn [acc b]
       (merge-with
        (fn [a b] (if (set? a) (conj a b) (hash-set a b)))
        acc b))
     (keys res)))

  (defn accumulate-var-triples
    "Takes a qvar, a value for that var and a query result map.
    Returns reducible of all triples for which the qvar has given value."
    [?v v res]
    (r/mapcat val (r/filter (fn [[k]] (= v (k ?v))) res)))

  (defn replace-result-vars
    "Takes a result map, a map of qvars to rename and a seq of qvars to remove.
      Returns updated result map."
    [res kmap rkeys]
    (reduce-kv
     (fn [res k v]
       (let [k (reduce dissoc k rkeys)]
         (assoc res (set/rename-keys k kmap) v)))
     {} res))

  (defn select-renamed-keys
    "Similar to clojure.core/select-keys, but instead of key seq takes a
    map of keys to be renamed (keys in that map are the original keys to
    be selected, their values the renamed keys in returned map)."
    [map aliases]
    (loop [ret {}, keys aliases]
      (if keys
        (let [kv (first keys)
              entry (. clojure.lang.RT (find map (key kv)))]
          (recur
           (if entry
             (conj ret [(val kv) (val entry)])
             ret)
           (next keys)))
        ret)))

  (defn triples->dot
    "Takes a seq of triples and returns them as digraph spec in
    Graphviz .dot format."
    [triples]
    (apply
     str
     (concat
      "digraph G {\n"
      "node[color=\"black\",style=\"filled\",fontname=\"Inconsolata\",fontcolor=\"white\"];\n"
      "edge[fontname=\"Inconsolata\",fontsize=\"9\"];\n"
      (map
       (fn [[s p o]]
         (str "\"" (pr-str s) "\" -> \"" (pr-str o) "\" [label=\"" (pr-str p) "\"];\n"))
       triples)
      "}")))

  (defn results->dot
    "Similar to triples->dot, but consumes query result map instead of
    plain triple seq."
    [res]
    (->> res (mapcat val) (set) (triples->dot)))
#+END_SRC

** Join

#+BEGIN_SRC clojure :noweb-ref joins
  (defn join
    [a b]
    (let [ka (keys a)
          kb (keys b)
          vka (keys (first ka))
          vkb (keys (first kb))]
      (->> (set/join ka kb)
           (r/map
            (if (= vka vkb)
              (fn [k]
                (if (unique-bindings? k)
                  (let [ks (select-keys k vka)
                        sa (a ks)
                        sb (b ks)]
                    [k (if (< (count sa) (count sb))
                         (into sb sa)
                         (into sa sb))])))
              (fn [k]
                (if (unique-bindings? k)
                  (let [sa (a (select-keys k vka))
                        sb (b (select-keys k vkb))]
                    [k (if (< (count sa) (count sb))
                         (into sb sa)
                         (into sa sb))])))))
           (into {}))))
#+END_SRC

** Select

#+BEGIN_SRC clojure :noweb-ref selectors
  (defn select-with-bindings
    [ds [s p o :as t] bindings]
    (let [[vs? vp? vo?] (mapv q/qvar? t)
          vm {}
          [qs vm] (if vs? [(bindings s) (assoc vm 0 s)] [s vm])
          [qp vm] (if vp? [(bindings p) (assoc vm 1 p)] [p vm])
          [qo vm] (if vo? [(bindings o) (assoc vm 2 o)] [o vm])
          verify (q/triple-verifier t [vs? vp? vo?])]
      (->> (select ds qs qp qo)
           (r/map
            (fn [r]
              (if (verify r)
                [(select-renamed-keys r vm) #{r}])))
           (into {}))))

  (defn select-join
    [ds [p & ps]]
    (let [res (select-with-bindings ds p {})]
      (if (seq res)
        (loop [res res, ps ps]
          (if ps
            (let [r' (select-with-bindings ds (first ps) {})
                  res (if (seq r') (join res r'))]
              (if (seq res)
                (recur res (next ps))))
            res)))))

  (defn select-transitive
    "Takes a PModel, a triple pattern and min/max search limits.
    The pattern's subject & object must be qvars, the predicate
    should be a transitive property. The fn tries to recursively
    find this pattern up to the given max search depth. The subject
    of the first and the object of the last matched pattern are then
    bound to the given qvars. Returns result map or empty map if no
    path of minimum length is found."
    [ds [s p o* :as t] min max]
    (let [o (make-qvar)
          res (select-with-bindings ds [s p o] {})]
      (when (seq res)
        (loop [res res, s o, i 1, ik []]
          (if (< i max)
            (let [o (make-qvar)
                  r' (select-with-bindings ds [s p o] {})]
              (if (seq r')
                (let [res' (join res r')]
                  (if (seq res')
                    (recur res' o (inc i) (conj ik s))
                    (if (>= i min)
                      (replace-result-vars res {s o*} ik)
                      {})))
                (replace-result-vars res {s o*} ik)))
            (replace-result-vars res {s o*} ik))))))
#+END_SRC

** Depth-first search

If same min/max search depth, resort to =select-join= with expanded pattern.
In that case predicate can be a seq =[pred1 pred2 ..]= which is
expanded cyclically for =depth= hops, e.g:

 : (dfs ds '[?s [mother father] ?o] 3 3)

Else, the fn takes a standard pattern with the subject or object either a given
constant or qvar:

Select all 'mother' rels from 1 - 3 hops (i.e. from mother -> great-grandmother)
 : (dfs ds '[?s mother ?c] 1 3)

If the object is not a qvar, search is executed backwards:
 : (dfs ds '[?m mother 'toxi])

Select only children & grandchildren for given person:
 : (dfs ds '[john father ?c] 2 2)
 : ;; same as...
 : (select-join ds '[[john father ?p] [?p father ?c]])

#+BEGIN_SRC clojure :noweb-ref dfs
  (defn subvec-slices
    "Takes a min & max count and returns function accepting a vector as
    single arg. When called, returns lazyseq of subvec slices each starting
    at index 0 and with an increasing length from min to max."
    [n1 n2]
    (fn [path]
      (map #(subvec path 0 %) (range n1 (inc (min (count path) n2))))))

  (defn dfs-forward*
    [ds s p sv acc triples min max]
    (if (<= (count acc) max)
      (let [acc (conj acc sv)
            o (make-qvar)
            r (select-with-bindings ds [s p o] {s sv})]
        (if (seq r)
          (r/mapcat
           (fn [ov]
             (let [t (accumulate-var-triples o ov r)]
               (dfs-forward* ds o p ov acc (into triples t) min max)))
           (set (map o (keys r))))
          (if (> (count acc) min) [[acc triples]])))
      [[acc triples]]))

  (defn dfs-backward*
    [ds o p ov acc triples min max]
    (if (<= (count acc) max)
      (let [acc (conj acc ov)
            s (make-qvar)
            r (select-with-bindings ds [s p o] {o ov})]
        (if (seq r)
          (r/mapcat
           (fn [sv]
             (let [t (accumulate-var-triples s sv r)]
               (dfs-backward* ds s p sv acc (into triples t) min max)))
           (set (map s (keys r))))
          (if (> (count acc) min) [[acc triples]])))
      [[acc triples]]))

  (defn dfs
    ([ds [s p o :as t]]
       (if (sequential? p)
         (dfs ds t (count p) (count p))
         (dfs ds t 1 1000000)))
    ([ds [s p o] mind maxd]
       (let [mind (max mind 1)
             maxd (max maxd 1)]
         (if (= mind maxd)
           (let [p (if (sequential? p) p [p])
                 p (take mind (cycle p))]
             (select-join ds (resolve-path-pattern [s p o])))
           (let [vs? (qvar? s)
                 vo? (qvar? o)
                 v (make-qvar)
                 conf (cond
                       (and vs? vo?) {:s s ;; [?s p ?o]
                                      :o v
                                      :bmap {}
                                      :lookup (fn [[b t]] [(b s) (b v) t])
                                      :bind (fn [[p t]] [{s (first p) o (peek p)} (set t)])
                                      :search dfs-forward*}
                       vo?           {:s v ;; [x p ?o]
                                      :o o
                                      :bmap {v s}
                                      :lookup (fn [[b t]] [(b v) (b o) t])
                                      :bind (fn [[p t]] [{o (peek p)} (set t)])
                                      :search dfs-forward*}
                       vs?           {:s s ;; [?s p x]
                                      :o v
                                      :bmap {v o}
                                      :lookup (fn [[b t]] [(b v) (b s) t])
                                      :bind (fn [[p t]] [{s (peek p)} (set t)])
                                      :search dfs-backward*})
                 {:keys [bind search]} conf
                 slices-k (subvec-slices (inc mind) (inc maxd))
                 slices-t (subvec-slices mind maxd)
                 slices (fn [[k t]] (map vector (slices-k k) (slices-t t)))]
             (->> (select-with-bindings ds [(:s conf) p (:o conf)] (:bmap conf))
                  (r/map (:lookup conf))
                  (r/mapcat #(search ds v p (% 1) [(% 0)] (vec (% 2)) mind maxd))
                  (r/mapcat slices)
                  (into {})
                  (r/map bind)
                  (into (hash-map))))))))
#+END_SRC

** Examples

#+BEGIN_SRC clojure
  (join
   (select-transitive ds '[?gp mother ?c] 0 100)
   (select-with-bindings ds '[?sp spouse ?p0] {}))

  (require
   '[thi.ng.trio.core :refer :all]
   '[thi.ng.trio.query2 :as q])

  (def ds (apply plain-store (read-string (slurp "../dev/schmidts.clj"))))

  (spit "schmidts.dot" (q/results->dot (q/dfs ds '[?s [mother father] ?c])))
#+END_SRC

** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/query2.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.query2
    (:require
     [thi.ng.trio.core :refer :all]
     [thi.ng.trio.query :as q]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.data.unionfind :as uf]
     [clojure.set :as set]
     [clojure.core.reducers :as r]))

  <<helpers>>

  <<joins>>

  <<selectors>>

  <<dfs>>
#+END_SRC
