#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.query2

** Helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn trace [id _] (dorun _) (prn "----") (prn id _) _)

  (defn qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (re-matches #"^\?.*" (name x))))

  (defn make-qvar
    "Creates a new auto-named qvar (symbol)."
    [] (gensym "?__q"))

  (defn resolve-path-pattern
    "Takes a path triple pattern where the predicate is a seq of preds.
    Returns seq of query patterns with injected temp qvars for inbetween
    patterns. E.g.

        [?s [p1 p2 p3] ?o]
        => ([?s p1 ?__q0] [?__q0 p2 ?__q1] [?__q1 p3 ?o])"
    [[s p o]]
    (let [vars (->> make-qvar
                    (repeatedly (dec (count p)))
                    (cons s))]
      (->> (concat (interleave vars p) [o])
           (d/successive-nth 3 2))))

  (defn unique-bindings?
    "Returns true if all values in the given map are unique, i.e.
    no two keys are mapped to the same value."
    [map] (== (count (into #{} (vals map))) (count map)))

  (defn produce-patterns-with-bound-vars
    "Takes a triple pattern (possibly with variables) and a map of
    possible value sets (each *must* be a set or single value) for each var.
    Produces lazy seq of resulting triple query patterns using cartesian
    product of all values.

        (produce-patterns-with-bound-vars
          [?a :type ?b]
          {?a #{\"me\" \"you\"} ?b #{\"foo\" \"bar\"})
        => ((\"me\" :type \"foo\") (\"me\" :type \"bar\")
            (\"you\" :type \"foo\") (\"you\" :type \"bar\"))"
    [[s p o] bindings]
    (let [s (or (bindings s) s)
          p (or (bindings p) p)
          o (or (bindings o) o)]
      (if (some set? [s p o])
        (d/cartesian-product
         (if (set? s) s #{s}) (if (set? p) p #{p}) (if (set? o) o #{o}))
        [[s p o]])))

  (defn sort-patterns
    "Sorts a seq of triple patterns in dependency order using any
    re-occuring vars. Triples with least qvars will be in head
    position."
    [patterns]
    (let [q (map #(let [v (d/filter-tree qvar? %)] [(count v) v %]) patterns)
          singles (->> q (filter #(= 1 (first %))) (mapcat second) set)]
      (->> q
           (sort-by (fn [[c v]] (- (* c 4) (count (filter singles v)))))
           (map peek))))

  (defn triple-verifier
    "Takes a triple pattern (potentially with vars) and a 3-elem boolean
    vector to indicate which SPO is a var. Returns fn which accepts a
    result triple and returns false if any of the vars clash (e.g. a var
    is used multiple times but result has different values in each position
    or likewise, if different vars relate to same values)."
    [[ts tp to] [vars varp varo]]
    (cond
     (and vars varp varo) (cond
                           (= ts tp to) (fn [[rs rp ro]] (= rs rp ro))
                           (= ts tp) (fn [[rs rp ro]] (and (= rs rp) (not= rs ro)))
                           (= ts to) (fn [[rs rp ro]] (and (= rs ro) (not= rs rp)))
                           (= tp to) (fn [[rs rp ro]] (and (= rp ro) (not= rs rp)))
                           :default (constantly true))
     (and vars varp) (if (= ts tp)
                       (fn [[rs rp]] (= rs rp))
                       (fn [[rs rp]] (not= rs rp)))
     (and vars varo) (if (= ts to)
                       (fn [[rs _ ro]] (= rs ro))
                       (fn [[rs _ ro]] (not= rs ro)))
     (and varp varo) (if (= tp to)
                       (fn [[_ rp ro]] (= rp ro))
                       (fn [[_ rp ro]] (not= rp ro)))
     :default (constantly true)))

  (defn accumulate-result-vars
    "Takes a query result map and returns map of all found qvars
    as keys and their value sets."
    ([res] (accumulate-result-vars {} nil res))
    ([acc vars res]
       (reduce
        (fn [acc b]
          (merge-with
           (fn [a b] (if (set? a) (conj a b) (hash-set a b)))
           acc (if vars (select-keys b vars) b)))
        acc (keys res))))

  (defn accumulate-var-triples
    "Takes a qvar, a value for that var and a query result map.
    Returns reducible of all triples for which the qvar has given value."
    [?v v res]
    (#+clj r/mapcat #+cljs mapcat val
           (#+clj r/filter #+cljs filter (fn [[k]] (= v (k ?v))) res)))

  (defn replace-result-vars
    "Takes a result map, a map of qvars to rename and a seq of qvars to remove.
      Returns updated result map."
    [res kmap rkeys]
    (reduce-kv
     (fn [res k v]
       (let [k (reduce dissoc k rkeys)]
         (assoc res (set/rename-keys k kmap) v)))
     {} res))

  (defn select-renamed-keys
    "Similar to clojure.core/select-keys, but instead of key seq takes a
    map of keys to be renamed (keys in that map are the original keys to
    be selected, their values the renamed keys in returned map)."
    [map aliases]
    (loop [ret {}, keys aliases]
      (if keys
        (let [kv (first keys)
              entry (find map (key kv))]
          (recur
           (if entry
             (conj ret [(val kv) (val entry)])
             ret)
           (next keys)))
        ret)))

  (defn triples->dot
    "Takes a seq of triples and returns them as digraph spec in
    Graphviz .dot format."
    [triples]
    (apply
     str
     (concat
      "digraph G {\n"
      "node[color=\"black\",style=\"filled\",fontname=\"Inconsolata\",fontcolor=\"white\"];\n"
      "edge[fontname=\"Inconsolata\",fontsize=\"9\"];\n"
      (map
       (fn [[s p o]]
         (str "\"" (pr-str s) "\" -> \"" (pr-str o) "\" [label=\"" (pr-str p) "\"];\n"))
       triples)
      "}")))

  (defn results->dot
    "Similar to triples->dot, but consumes query result map instead of
    plain triple seq."
    [res]
    (->> res (mapcat val) (set) (triples->dot)))
#+END_SRC

** Join

#+BEGIN_SRC clojure :noweb-ref joins
  (defn join
    [a b]
    (let [ka (keys a)
          kb (keys b)
          vka (keys (first ka))
          vkb (keys (first kb))]
      (->> (set/join ka kb)
           (#+clj r/map #+cljs map
                  (if (= vka vkb)
                    (fn [k]
                      (if (unique-bindings? k)
                        (let [ks (select-keys k vka)
                              sa (a ks)
                              sb (b ks)]
                          [k (if (< (count sa) (count sb))
                               (into sb sa)
                               (into sa sb))])))
                    (fn [k]
                      (if (unique-bindings? k)
                        (let [sa (a (select-keys k vka))
                              sb (b (select-keys k vkb))]
                          [k (if (< (count sa) (count sb))
                               (into sb sa)
                               (into sa sb))])))))
           (into {}))))

  (defn join-optional
    [a b]
    (let [[new old] (reduce
                     (fn [acc [kb vb]]
                       (reduce
                        (fn [acc [ka va]]
                          (let [j (first (set/join #{ka} #{kb}))]
                            (if j
                              (reduced
                               [(assoc (acc 0) j (into va vb))
                                (conj (acc 1) ka)])
                              acc)))
                        acc a))
                     [{} #{}] b)]
      (if (seq new)
        (into (apply dissoc a old) new)
        a)))
#+END_SRC

** Select

#+BEGIN_SRC clojure :noweb-ref selectors
  (defn select-with-bindings
    [ds [s p o :as t] bindings opts]
    (let [[vs? vp? vo?] (mapv qvar? t)
          vm {}
          [qs vm] (if vs? [(bindings s) (assoc vm 0 s)] [s vm])
          [qp vm] (if vp? [(bindings p) (assoc vm 1 p)] [p vm])
          [qo vm] (if vo? [(bindings o) (assoc vm 2 o)] [o vm])
          res (api/select ds qs qp qo)]
      (if (seq res)
        (let [verify (triple-verifier t [vs? vp? vo?])
              flt (opts :filter)
              res-fn (if flt
                       #(if (verify %)
                          (let [vbinds (select-renamed-keys % vm)]
                            (if (flt vbinds)
                              [vbinds #{%}])))
                       #(if (verify %)
                          [(select-renamed-keys % vm) #{%}]))]
          (->> res
               (#+clj r/map #+cljs map res-fn)
               (into {})))
        {})))

  (defn select-join
    [ds patterns bindings {bind :bind flt :filter}]
    (let [[p & ps] (sort-patterns patterns)
          res (select-with-bindings ds p bindings {})]
      ;;(prn p ps)
      (if (seq res)
        (loop [res res, ps ps]
          (if ps
            (let [r' (select-with-bindings ds (first ps) bindings {})
                  res (if (seq r') (join res r'))]
              (if (seq res)
                (recur res (next ps))))
            (cond-> res
                    flt (->> (filter (fn [r] (flt (r 0)))) (into {}))
                    bind (->> (map (fn [[k v]] [(bind k) v])) (into {}))))))))
#+END_SRC

** Depth-first search

If same min/max search depth, resort to =select-join= with expanded pattern.
In that case predicate can be a seq =[pred1 pred2 ..]= which is
expanded cyclically for =depth= hops, e.g:

 : (dfs ds '[?s [mother father] ?o] 3 3)

Else, the fn takes a standard pattern with the subject or object either a given
constant or qvar:

Select all 'mother' rels from 1 - 3 hops (i.e. from mother -> great-grandmother)
 : (dfs ds '[?s mother ?c] 1 3)

If the object is not a qvar, search is executed backwards:
 : (dfs ds '[?m mother 'toxi])

Select only children & grandchildren for given person:
 : (dfs ds '[john father ?c] 2 2)
 : ;; same as...
 : (select-join ds '[[john father ?p] [?p father ?c]])

#+BEGIN_SRC clojure :noweb-ref dfs
  (defn subvec-slices
    "Takes a min & max count and returns function accepting a vector as
    single arg. When called, returns lazyseq of subvec slices each starting
    at index 0 and with an increasing length from min to max."
    [n1 n2]
    (fn [path]
      (map #(subvec path 0 %) (range n1 (inc (min (count path) n2))))))

  (defn dfs-forward*
    [ds s p sv acc triples min max]
    (if (<= (count acc) max)
      (let [acc (conj acc sv)
            o (make-qvar)
            r (select-with-bindings ds [s p o] {s sv} {})]
        (if (seq r)
          (#+clj r/mapcat #+cljs mapcat
           (fn [ov]
             (let [t (accumulate-var-triples o ov r)]
               (dfs-forward* ds o p ov acc (into triples t) min max)))
           (set (map o (keys r))))
          (if (> (count acc) min) [[acc triples]])))
      [[acc triples]]))

  (defn dfs-backward*
    [ds o p ov acc triples min max]
    (if (<= (count acc) max)
      (let [acc (conj acc ov)
            s (make-qvar)
            r (select-with-bindings ds [s p o] {o ov} {})]
        (if (seq r)
          (#+clj r/mapcat #+cljs mapcat
           (fn [sv]
             (let [t (accumulate-var-triples s sv r)]
               (dfs-backward* ds s p sv acc (into triples t) min max)))
           (set (map s (keys r))))
          (if (> (count acc) min) [[acc triples]])))
      [[acc triples]]))

  (defn dfs
    ([ds [s p o :as t]]
       (if (sequential? p)
         (dfs ds t (count p) (count p))
         (dfs ds t 1 1000000)))
    ([ds [s p o] mind maxd]
       (let [mind (max mind 1)
             maxd (max maxd 1)]
         (if (= mind maxd)
           (let [p (if (sequential? p) p [p])
                 p (take mind (cycle p))]
             (select-join ds (resolve-path-pattern [s p o]) {} {}))
           (let [vs? (qvar? s)
                 vo? (qvar? o)
                 v (make-qvar)
                 conf (cond
                       (and vs? vo?) {:s s ;; [?s p ?o]
                                      :o v
                                      :bmap {}
                                      :lookup (fn [[b t]] [(b s) (b v) t])
                                      :bind (fn [[p t]] [{s (first p) o (peek p)} (set t)])
                                      :search dfs-forward*}
                       vo?           {:s v ;; [x p ?o]
                                      :o o
                                      :bmap {v s}
                                      :lookup (fn [[b t]] [(b v) (b o) t])
                                      :bind (fn [[p t]] [{o (peek p)} (set t)])
                                      :search dfs-forward*}
                       vs?           {:s s ;; [?s p x]
                                      :o v
                                      :bmap {v o}
                                      :lookup (fn [[b t]] [(b v) (b s) t])
                                      :bind (fn [[p t]] [{s (peek p)} (set t)])
                                      :search dfs-backward*})
                 {:keys [bind search]} conf
                 slices-k (subvec-slices (inc mind) (inc maxd))
                 slices-t (subvec-slices mind maxd)
                 slices (fn [[k t]] (map vector (slices-k k) (slices-t t)))]
             (->> (select-with-bindings ds [(:s conf) p (:o conf)] (:bmap conf) {})
                  (#+clj r/map    #+cljs map    (:lookup conf))
                  (#+clj r/mapcat #+cljs mapcat #(search ds v p (% 1) [(% 0)] (vec (% 2)) mind maxd))
                  (#+clj r/mapcat #+cljs mapcat slices)
                  (into {})
                  (#+clj r/map    #+cljs map    bind)
                  (into (hash-map))))))))
#+END_SRC

** Examples

#+BEGIN_SRC clojure
  (join
   (select-transitive ds '[?gp mother ?c] 0 100)
   (select-with-bindings ds '[?sp spouse ?p0] {}))

  (require
   '[thi.ng.trio.core :refer :all]
   '[thi.ng.trio.query2 :as q])

  (def ds (apply plain-store (read-string (slurp "../dev/schmidts.clj"))))

  (spit "schmidts.dot" (q/results->dot (q/dfs ds '[?s [mother father] ?c])))
#+END_SRC

** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/query2.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.query2
    (:require
     [thi.ng.trio.core :as api]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.data.unionfind :as uf]
     [clojure.set :as set]
     #+clj [clojure.core.reducers :as r]))

  <<helpers>>

  <<joins>>

  <<selectors>>

  <<dfs>>
#+END_SRC
