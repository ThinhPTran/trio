#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.query

** Highlevel query processing

Triplestores not just provide high flexibility in terms of data
organization and storage, but also for querying purposes. The query
engine implemented in this namespace is conceptually based on [[http://www.w3.org/TR/sparql11-query][W3C
SPARQL]] and also boroughs some of its terminology, however does not
entail any RDF specifics or semantics. Datalog (as used by Datomic)
too is similar in approach and both are essentially based on
describing & matching patterns in a directed graph.

*** Query engine features

| *Feature*                         | *Status*   |
|-----------------------------------+------------|
| Query planning                    | INPROGRESS |
| Query compilation                 | DONE       |
| Subqueries                        | DONE       |
| Multi-graph queries               | DONE       |
| Direct query of clj triple seqs   | DONE       |
| Filtering (per sub-query)         | DONE       |
| Joins (fail fast)                 | DONE       |
| Optional joins                    | DONE       |
| Union (match alternatives)        | DONE       |
| Subtraction (negation)            | DONE       |
| Arbitrary-length paths queries    | INPROGRESS |
| Result graph construction         | INPROGRESS |
| Result graph extraction           | INPROGRESS |
| Result var binding injection      | DONE       |
| Result ordering on arbitrary vars | DONE       |
| Result grouping                   | DONE       |
| Result aggregate expressions      | INPROGRESS |
| Aggregate filters                 | INPROGRESS |

More generally, the engine design was guided by:

- no macro magic, completely functional
- use plain hash maps to formulate and dynamically compose query specs
- easy to read syntax, no cryptic symbols
- vanilla Clojure fns for predicates, binding & aggregate fns

*** Examples

To introduce some of the query engine features, let's define a small graph of relationships:

#+NAME: example-graph-table
| *Subject* | *Predicate* | *Object* |
|-----------+-------------+----------|
| alice     | friend      | bob      |
| alice     | age         | 34       |
| bob       | friend      | carl     |
| bob       | nick        | bobby    |
| carl      | spouse      | alice    |
| carl      | father      | donald   |
| carl      | age         | 42       |
| bob       | father      | emily    |
| emily     | age         | 23       |
| freya     | mother      | emily    |
| emily     | nick        | em       |
| donald    | friend      | emily    |

#+BEGIN_SRC dot :noweb yes :file ../assets/query-example01.png :exports results
  digraph G {
    node[color="black",style="filled",fontname="Inconsolata",fontcolor="white",fontsize=11];
    edge[fontname="Inconsolata",fontsize=9];
    <<lob-make-dot(graph-table=example-graph-table)>>
  }
#+END_SRC

[[../assets/query-example01.png]]

In Clojure this graph would be defined like this:

#+BEGIN_SRC clojure
  (require '[thi.ng.trio.core :refer :all])
  (require '[thi.ng.trio.query :as q])

  (def g
    (->>
     '[[alice   friend  bob]
       [alice   age     34]
       [bob     friend  carl]
       [bob     nick    bobby]
       [carl    spouse  alice]
       [carl    father  donald]
       [carl    age     42]
       [bob     father  emily]
       [emily   age     23]
       [freya   mother  emily]
       [emily   nick    em]
       [donald  friend  emily]]
     (apply plain-store)))
#+END_SRC

**** Selection

Now let's query this graph to find some information about all parents & children:

- perform alternative queries to bind =?p= to fathers or mothers of any child =?c=
- optionally retrieve child's age =?a=
- inject result var binding/mapper to format age as descriptive string
- sort results by child name

#+BEGIN_SRC clojure
  (q/query
   {:select :*
    :from g
    :query [{:where '[[?p father ?c]]}
            {:union '[[?p mother ?c]]}
            {:optional '[[?c age ?a]]}]
    :bind {'?a (fn [res a] (if a (str (res '?c) " is " a " years old")))}
    :order-asc '?c})

  ;; => ({?p carl, ?c donald} {?a "emily is 23 years old", ?p freya, ?c emily} {?a "emily is 23 years old", ?p bob, ?c emily})
#+END_SRC

**** Graph construction / inference

Since we know Carl's spouse is Alice, but we don't have explicity
stated her as Donald's mother, we could create a query that produces a
number of inferred facts based on these following rules:

1. for every =?f= father of =?c= and where =?m= spouse of =?f=, we declare =?m= mother of =?c=
2. for every =?m= mother of =?c= and where =?f= spouse of =?m=, we declare =?f= father of =?c=
3. for every =?f= father of =?c= and =?m= mother of =?c=, we declare =?f= spouse =?m= (and vice versa)
4. declare a new =parent= relationship for each father/mother
5. assign gender information for each parent
6. declare a new =child-of= relationship for each child

In order to create these new facts we can use a =:construct= type query and we will also compile it first:

#+BEGIN_SRC clojure
  (def infer-parents
    (q/compile-query
     {:from g
      :construct '[[?f father ?c] [?m mother ?c]       ;; rule 1 + 2
                   [?f spouse ?m] [?m spouse ?f]       ;; rule 3
                   [?f parent ?c] [?m parent ?c]       ;; rule 4
                   [?f gender male] [?m gender female] ;; rule 5
                   [?c child-of ?f] [?c child-of ?m]]  ;; rule 6
      :query [{:where '[[?f father ?c] [?f spouse ?m]]}
              {:union '[[?m mother ?c] [?m spouse ?f]]}
              {:union '[[?f father ?c] [?m mother ?c]]}]}))

  (q/query infer-parents)

  ;; #{[freya spouse bob] [emily child-of bob] [carl parent donald] [bob gender male]
  ;;   [alice parent donald] [carl father donald] [freya mother emily] [donald child-of alice]
  ;;   [alice gender female] [alice mother donald] [bob spouse freya] [emily child-of freya]
  ;;   [freya gender female] [bob parent emily] [carl spouse alice] [donald child-of carl]
  ;;   [bob father emily] [alice spouse carl] [carl gender male] [freya parent emily]}
#+END_SRC

Now we can add these inferred triples to our graph and test it:

#+BEGIN_SRC clojure
  (def g2 (add-bulk g (q/query infer-parents)))

  (q/query {:select :* :from g2 :query [{:where '[[?p parent ?c]]}] :group '?c})

  ;; => {emily [{?p bob, ?c emily} {?p freya, ?c emily}], donald [{?p carl, ?c donald} {?p alice, ?c donald}]}
#+END_SRC

The new graph with inferred triples marked in red:

[[../assets/query-example02.png]]

**** Subgraph extraction

As a final introductory example, let's demonstrate how to extract
anything we know about subjects matched via an initial query/search,
in this case people with nicknames and who are younger than 40. A
=:describe= query returns all triples in which a bound result var is
either a subject or object.

#+BEGIN_SRC clojure
  (q/query {:describe '?p :from g2 :query [{:where '[[?p nick ?n] [?p age ?a]] :filter {'?a #(< % 40)}}]})

  ;; => #{[emily child-of bob] [emily child-of freya] [emily nick em] [emily age 23]
  ;;      [donald friend emily] [freya mother emily] [freya parent emily] [bob parent emily] [bob father emily]}
#+END_SRC

The extracted sub-graph defined by the result triples (edges in red are the matched query terms):

[[../assets/query-example03.png]]

** Query compiler
# <<queryopts>>
*** Query options (filters, var injection)

Each subquery can define its own filters & variable injections. These
query options are passed via the =:filter= and =:bind= keys. Both
assume a function which is applied to each result binding map.
However, for most use cases it is more convenient to specify these
functions for individual query vars only and the following helpers
allow us to do so.

For example this sub-query asks for artists under 25 and injects a new
qvar =?fullname= into each result:

#+BEGIN_SRC clojure
  {:where '[[?s :type :artist] [?s :age ?a] [?s :fname ?fn] [?s :surname ?sn]]
   :filter {'?a #(< % 25)}
   :bind   {'?fullname (fn [res _] (str (res '?fn) " " (res '?sn)))}}
#+END_SRC

If specified in this manner (as map with qvars as keys), =:filter=
functions must accept a single arg, i.e. the value of the qvar
binding. Any truthy return value will keep the result.

On the other hand, =:bind= fns must accept 2 args: the full
result map and the related qvar's value. The return value will be
bound to the specified qvar in each result/solution, unless the
function returns =nil=.

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn compile-filter-fn
    [filters]
    (if filters
      (if (fn? filters)
        filters
        (fn [res] (every? (fn [[k f]] (if-let [rv (res k)] (f rv) false)) filters)))))

  (defn compile-bind-fn
    [bindings]
    (if bindings
      (if (fn? bindings)
        bindings
        (fn [res]
          (reduce-kv
           (fn [acc k f]
             (let [rv (f res (res k))]
               (if (nil? rv) (assoc acc k rv) acc)))
           res bindings)))))

  (defn query-opts
    [opts]
    (-> opts
        (update-in [:filter] compile-filter-fn)
        (update-in [:bind] compile-bind-fn)))
#+END_SRC

*** Compiler steps

The role of the query compiler is to translate query specs (plain
hashmaps) into actual working code, as well as to reduce
pre-processing for repetive queries. This compilation is realized via
the =compile-query-step= multimethod in order to cleanly separate
logic for each query element and keep the code legible.

#+BEGIN_SRC clojure :noweb-ref compiler
  (defmulti compile-query-step
    (fn [qfn q type] type))
#+END_SRC

Essentially, each compile step is using composition to wrap its
predecessor and combine that result with its own. To allow fail-fast
behaviors for some phases, the namespaced =::empty= keyword is used as
sentinel to distinguish the initially empty result set from an earlier
failed search (=nil=).

**** Public query API

Currently, the query engine's public API consist of only these two
functions. =query= accepts both pre-compiled queries or raw query
specs. An exception is thrown if there're compile errors.

#+BEGIN_SRC clojure :noweb-ref compiler
  (defn compile-query
    [q]
    (if-let [type (some #{:select :ask :construct :describe} (keys q))]
      (compile-query-step identity q type)
      (err/unsupported! "Unsupported query type")))

  (defn query
    [q]
    (let [res ((if (fn? q) q (compile-query q)) ::empty)]
      (if (seq res) res)))
#+END_SRC

**** Sub queries

The engine currently supports the following subquery types:

| *Type*        | *Key*     | *Options*                 | *Description*                                   |
|---------------+-----------+---------------------------+-------------------------------------------------|
| join          | :where    | :from :filter :bind :with | join/intersection of given patterns (fail fast) |
| join optional | :optional | :from :filter :bind :with | natural join of given patterns                  |
| union         | :union    | :from :filter :bind :with | add results to existing                         |
| negation      | :minus    | :from :filter :bind :with | remove results from existing                    |

#+BEGIN_SRC clojure :noweb-ref compiler
  (defn query-step
    [qfn join-fn {:keys [from with] :as q} patterns]
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)
              b (select-join from with opts patterns)
              res' (if (= ::empty a) b (join-fn a b))]
          res'))))

  (defmethod compile-query-step :join
    [qfn {:keys [from with where] :as q} _]
    (prn :join where with)
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)]
          (if (or (= ::empty a) (seq a))
            (let [b (select-join from with opts where)
                  res' (if (= ::empty a) b (join a b))]
              res')
            a)))))

  (defmethod compile-query-step :minus
    [qfn {:keys [from with minus] :as q} _]
    (prn :minus minus with)
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)]
          (if (seq a)
            (thi.ng.trio.query/minus a (select-join from with opts minus))
            a)))))

  (defmethod compile-query-step :optional
    [qfn {:keys [from with optional] :as q} _]
    (prn :join-opt optional with)
    (query-step qfn join-optional q optional))

  (defmethod compile-query-step :union
    [qfn {:keys [from with union] :as q} _]
    (prn :union union with)
    (query-step qfn thi.ng.trio.query/union q union))
#+END_SRC

**** Subquery dispatch

#+BEGIN_SRC clojure :noweb-ref compiler
  (defmethod compile-query-step :multi-query
    [qfn {:keys [from with query]} _]
    (prn :multi query)
    (loop [qfn qfn, query query]
      (if query
        (let [q (first query)
              from (or (:from q) from)
              q (cond
                 (satisfies? api/PModel from)
                 (assoc q :from from)

                 (satisfies? api/PModelConvert from)
                 (assoc q :from (api/as-model from)))
              q (if (:with q) q (assoc q :with (or with {})))
              qfn (cond
                   (:where q)    (compile-query-step qfn q :join)
                   (:optional q) (compile-query-step qfn q :optional)
                   (:minus q)    (compile-query-step qfn q :minus)
                   (:union q)    (compile-query-step qfn q :union))]
          (recur qfn (next query)))
        qfn)))
#+END_SRC

**** Result processing

#+BEGIN_SRC clojure :noweb-ref compiler
  (defmethod compile-query-step :bind
    [qfn bind _]
    (prn :bindings bind)
    (let [bind (compile-bind-fn bind)]
      (fn [res] (map bind (qfn res)))))

  (defmethod compile-query-step :order-asc
    [qfn order _]
    (prn :order-asc order)
    (fn [res] (order-asc order (qfn res))))

  (defmethod compile-query-step :order-desc
    [qfn order _]
    (prn :order-desc order)
    (fn [res] (order-desc order (qfn res))))
#+END_SRC

**** Result projection

#+BEGIN_SRC clojure :noweb-ref compiler
  (defn renamed-vars
    [binding-map]
    (reduce-kv
     (fn [vars k v]
       (if (and (map? v) (:as v))
         (assoc vars (:as v) v)
         (assoc vars k v)))
     {} binding-map))

  (defn selected-var-keys
    [qvars]
    (reduce
     (fn [vars v]
       (if (map? v)
         (merge vars v)
         (assoc vars v v)))
     {} qvars))

  (defn parse-var-bind-spec
    [v spec] (if (map? spec) [(or (:use spec) v) (:fn spec)] [nil spec]))

  (defn compute-select-bindings
    [res svars]
    (reduce-kv
     (fn [acc v spec]
       (let [[k f] (parse-var-bind-spec v spec)]
         (if k
           (assoc acc v (if (fn? f) (f (res k)) (res k)))
           (assoc acc v (f res)))))
     {} svars))

  (defn validate-selected-vars
    [svars]
    (if (svars :*)
      (if (> (count svars) 1)
        (err/illegal-arg! (str "can't use :* selector with other vars: " (vals svars)))
        (dissoc svars :*))
      svars))

  (defmethod compile-query-step :project-vars
    [qfn {:keys [select group] :as q} _]
    (prn :project-vars select)
    (if group
      (compile-query-step qfn q :project-aggregates)
      (let [select     (if (sequential? select) select [select])
            svars      (selected-var-keys select)
            catch-all? (svars :*)
            svars      (validate-selected-vars svars)]
        (if catch-all?
          qfn
          (fn [res] (map #(compute-select-bindings % svars) (qfn res)))))))
#+END_SRC

**** Result aggregates

The following example graph maps authors to their books & prices. We
will query this graph using grouping and compute some aggregate stats
for each author:

#+BEGIN_SRC clojure
  (defn avg [vals] (/ (reduce + vals) (count vals)))
  (defn max' [vals] (reduce max vals))

  (def ds
    (as-model
     '[[a1 author [b1 b2]]
       [a2 author b3]
       [a3 author b4]
       [b1 price 10]
       [[b2 b4] price 20]
       [b3 price 5]]))
#+END_SRC

[[../assets/aggregates.png]]

#+BEGIN_SRC clojure
  ;; retrieve book prices, group by author
  ;; compute avg. & max price, group size per author
  ;; filter by avg.

  (q/query
   {:select '[?avg ?max ?num]
    :from ds
    :query '[{:where [[?a author ?b] [?b price ?p]]}]
    :group '?a
    :aggregate {'?avg {:use '?p :fn avg}
                '?max {:use '?p :fn max'}
                '?num count}
    :having {'?avg #(> % 10)}})

  ;; => {a3 {?avg 20, ?max 20, ?num 1}, a1 {?avg 15, ?max 20, ?num 2}}
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref compiler
  (defn compute-aggregates
    [vars vals]
    (reduce-kv
     (fn [inner v spec]
       (let [[k f] (parse-var-bind-spec v spec)]
         (if k
           (assoc inner v (f (map #(get % k) vals)))
           (assoc inner v (f vals)))))
     {} vars))

  (defmethod compile-query-step :project-aggregates-only
    [qfn [avars svars filter] _]
    (prn :aggregates-only avars filter)
    (fn [res]
      (->> (qfn res)
           (reduce-kv
            (fn [acc k vals]
              (let [agg (compute-aggregates avars vals)]
                (if (or (nil? filter) (filter agg))
                  (assoc acc k (compute-select-bindings agg svars))
                  acc)))
            {}))))

  (defmethod compile-query-step :project-aggregates-mixed
    [qfn [avars svars all? flt] _]
    (prn :mixed-aggregates avars svars all? flt)
    (fn [res]
      (->> (qfn res)
           (reduce-kv
            (fn [acc k vals]
              (let [agg  (compute-aggregates avars vals)
                    vals (map #(merge % agg) vals)
                    vals (if flt (filter flt vals) vals)]
                (if (seq vals)
                  (if all?
                    (assoc acc k vals)
                    (assoc acc k (map #(compute-select-bindings % svars) vals)))
                  acc)))
            {}))))

  (defmethod compile-query-step :project-aggregates-simple
    [qfn [vars flt] _]
    (prn :simple-aggregates vars flt)
    (fn [res]
      (->> (qfn res)
           (reduce-kv
            (fn [acc k vals]
              (let [vals (if flt (filter flt vals) vals)]
                (if (seq vals)
                  (assoc acc k (map #(compute-select-bindings % vars) vals))
                  acc)))
            {}))))

  (defmethod compile-query-step :project-aggregates-all
    [qfn flt _]
    (prn :all-aggregates flt)
    (fn [res]
      (->> (qfn res)
           (reduce-kv
            (fn [acc k vals]
              (let [vals (if flt (filter flt vals) vals)]
                (if (seq vals)
                  (assoc acc k vals)
                  acc)))
            {}))))

  (defmethod compile-query-step :project-aggregates
    [qfn {:keys [select group aggregate having] :as q} _]
    (prn :project-aggregates group aggregate)
    (let [select     (if (sequential? select) select [select])
          svars      (selected-var-keys select)
          catch-all? (svars :*)
          svars      (validate-selected-vars svars)
          agg-only?  (every? (set (keys aggregate)) (keys svars))
          filter     (compile-filter-fn having)
          qfn        (fn [res] (group-by group (qfn res)))]
      (prn :svars svars)
      (if (seq aggregate)
        (if (and agg-only? (not catch-all?))
          (compile-query-step qfn [aggregate svars filter] :project-aggregates-only)
          (compile-query-step qfn [aggregate svars catch-all? filter] :project-aggregates-mixed))
        (if catch-all?
          (compile-query-step qfn filter :project-aggregates-all)
          (compile-query-step qfn [svars filter] :project-aggregates-simple)))))
#+END_SRC

**** Query type: SELECT

*Purpose:* Match patterns in graph, return sequence of all found
solutions. Each solution is a map of unique qvar bindings.

*Use cases:*
- General graph queries / pattern matching
- Result transformations
- 
| *Key*       | *Value(s)*                | *Description*                                                      | *Required* |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :select     | :*                        | Solutions contain all used qvars                                   | yes        |
|             | '?var                     | Solutions contain only this single qvar                            |            |
|             | '[?v1 ?v2 ...]            | Solutions contain only given qvars                                 |            |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :from       | trio.core/PModel instance | Default triplestore to use for all sub-queries                     | yes        |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :query      | [{sub-query} ...]         | Seq of any number of sub-queries (see [[Sub queries]])                 | yes        |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :bind       | fn or bindings map        | Inject/transform qvars in final solutions                          | no         |
|             |                           | (see [[queryopts][Query options]])                                                |            |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :with       | '{?v1 #{a b} ?v2 c}       | Pre-bind qvars to given values for all subqueries                  | no         |
|             |                           | in order to constrain search.                                      |            |
|             |                           | If a value set is specified for a qvar, attempts all options given |            |
|             |                           |                                                                    |            |
|             |                           | *Note:* The same effect can be achieved with filters,              |            |
|             |                           | though pre-binding will produce optimized queries                  |            |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :order-asc  | '?var                     | Sort solutions by qvar (ascending)                                 | no         |
|             | '[?v1 ?v2 ..]             | Nested sort by first ?v1, ?v2 ...                                  |            |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :order-desc | same as =:order-asc=      | Sort solutions by qvar (descending)                                | no         |
|-------------+---------------------------+--------------------------------------------------------------------+------------|
| :group      | '?var                     | Group solutions by qvar                                            | no         |
|             | (fn [res] group-key)      | Group solutions by return value of fn                              |            |
|             |                           |                                                                    |            |
|             |                           | *Note:*                                                            |            |
|             |                           | - returns solutions as map (not as seq)                            |            |
|             |                           | - grouping occurs /after/ qvar filtering,                          |            |
|             |                           | - hence can only group by qvars in =:select=                       |            |

#+BEGIN_SRC clojure :noweb-ref compiler
  (defmethod compile-query-step :select
    [qfn {:keys [select from query bind order-asc order-desc group] :as q} _]
    (prn :select select)
    (cond->
     (compile-query-step qfn q :multi-query)
     bind       (compile-query-step bind :bind)
     order-asc  (compile-query-step order-asc :order-asc)
     order-desc (compile-query-step order-desc :order-desc)
     true       (compile-query-step q :project-vars)))
#+END_SRC

**** Query type: CONSTRUCT

*Purpose:* Matches patterns in graph(s) and binds values to qvars,
then construct new triples using bound qvars solutions. Returns seq of
constructed triples.

*Use cases:*
- Inference
- Triple mapping/updating
- Reification
- Annotation
- Adding of provenance data

| *Key*      | *Value(s)*                | *Description*                                      | *Required* |
|------------+---------------------------+----------------------------------------------------+------------|
| :construct | [pattern ...]             | solutions contain all used qvars                   | yes        |
|------------+---------------------------+----------------------------------------------------+------------|
| :from      | trio.core/PModel instance | default triplestore to use for all sub-queries     | yes        |
|------------+---------------------------+----------------------------------------------------+------------|
| :query     | [{sub-query} ...]         | seq of any number of sub-queries (see [[Sub queries]]) | yes        |
|------------+---------------------------+----------------------------------------------------+------------|
| :bind      | fn or bindings map        | inject/transform qvars in final solutions          | no         |
|            |                           | (see [[queryopts][Query options]])                                |            |

Any other options supported by =:select= will be removed from the
query spec.

#+BEGIN_SRC clojure :noweb-ref compiler
  (defmethod compile-query-step :construct-triples
    [qfn {:keys [construct] :as q} _]
    (fn [res]
      (->> res
           qfn
           (mapcat
            (fn [r]
              (map
               (fn [[s p o]]
                 (let [s (if (qvar? s) (r s) s)
                       p (if (qvar? p) (r p) p)
                       o (if (qvar? o) (r o) o)]
                   (if (and s p o) (api/triple s p o))))
               construct)))
           (filter identity)
           (set))))

  (defmethod compile-query-step :construct
    [qfn q _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :group)
                (assoc :select :*))]
      (-> qfn
          (compile-query-step q :select)
          (compile-query-step q :construct-triples))))
#+END_SRC

**** Query type: ASK

#+BEGIN_SRC clojure :noweb-ref compiler
  (defmethod compile-query-step :ask
    [qfn q _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :bind :group)
                (assoc :select :*))
          qfn (compile-query-step qfn q :select)]
      (fn [res] (if (seq (qfn res)) true false))))
#+END_SRC

**** Query type: DESCRIBE

*Purpose:* Extract sub-graphs for nodes matched via query.

*Use cases:*

- REST APIs
- Graph partitioning/segmentation

*Options:*

| *Key*     | *Value(s)*                | *Description*                                              | *Required* |
|-----------+---------------------------+------------------------------------------------------------+------------|
| :describe | '?var                     | select sub-graphs of nodes in the value set of single qvar | yes        |
|           | '[?v1 ?v2 ...]            | select sub-graphs of given qvar value sets                 |            |
|-----------+---------------------------+------------------------------------------------------------+------------|
| :from     | trio.core/PModel instance | default triplestore to use for all sub-queries             | yes        |
|-----------+---------------------------+------------------------------------------------------------+------------|
| :query    | [{sub-query} ...]         | seq of any number of sub-queries (see [[Sub queries]])         | yes        |
|-----------+---------------------------+------------------------------------------------------------+------------|
| :bind     | fn or bindings map        | inject/transform qvars in final solutions                  | no         |
|           |                           | (see [[queryopts][Query options]])                                        |            |

Any other options supported by =:select= will be removed from the
query spec.

#+BEGIN_SRC clojure :noweb-ref compiler
  (defmethod compile-query-step :describe
    [qfn {:keys [from describe] :as q} _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :group)
                (assoc :select :*))
          qfn (compile-query-step qfn q :select)
          describe (if (sequential? describe) describe [describe])]
      (fn [res]
        (let [res (qfn res)
              vars (select-keys (accumulate-result-vars res) describe)]
          (if (seq vars)
            (reduce
             (fn [acc v]
               (let [vals (vars v)]
                 (-> acc
                     (into (mapcat #(api/select from % nil nil) vals))
                     (into (mapcat #(api/select from nil nil %) vals)))))
             #{} (keys vars)))))))
#+END_SRC

** Helpers
*** Query variables
#+BEGIN_SRC clojure :noweb-ref helpers
  (def ^:dynamic *auto-qvar-prefix* "?__q")

  (defn qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (re-matches #"^\?.*" (name x))))

  (defn auto-qvar?
    "Returns true, if x is an auto-generated qvar
    (a symbol prefixed with *auto-qvar-prefix*)"
    [x] (and (symbol? x) (zero? (.indexOf ^String (name x) *auto-qvar-prefix*))))

  (defn auto-qvar
    "Creates a new auto-named qvar (symbol)."
    [] (gensym *auto-qvar-prefix*))

  (defn qvar-name
    [x] (-> x name (subs 1)))
#+END_SRC

*** Query pattern resolution & handling
**** Specifying variable length paths

- http://www.w3.org/TR/sparql11-query/#propertypaths

| *Path pattern*          | *Description*                        | *Meaning*                                                     |
|-------------------------+--------------------------------------+---------------------------------------------------------------|
| =[?s [p1 p2] ?o]=       | fixed length path between =?s=, =?o= | equivalent to: ={:where '[[?s p1 ?x] [?x p2 ?o]}=             |
| =[?s [:? p1 p2] ?o]=    | fixed length path, optional          | if path exists *fully*, bind =?s=, =?o=                       |
| =[?s [:+ p1 p2] ?o]=    | full path, cyclic                    | if path exists *fully* one or more times, bind =?s=, =?o=     |
| =[?s [:* p1 p2] ?o]=    | partial path, cyclic                 | if path exists *partially* one or more times, bind =?s=, =?o= |
| =[?s [:not p] ?o]=      | single edge *not* via =p=            | equivalent to: ={:where [?s ?pp ?o]} {:minus [?s p ?o]}=      |
| =[?s [:or p1 p2] ?o]=   | single edge =p1= *or* =p2=           | equivalent to: ={:where [?s p1 ?o]} {:union [?s p2 ?o]}=      |

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn resolve-path-pattern
    "Takes a path triple pattern where the predicate is a seq of preds.
    Returns seq of query patterns with injected temp qvars for inbetween
    patterns. E.g.

        [?s [p1 p2 p3] ?o]
        => ([?s p1 ?__q0] [?__q0 p2 ?__q1] [?__q1 p3 ?o])"
    [[s p o]]
    (let [vars (->> auto-qvar
                    (repeatedly (dec (count p)))
                    (cons s))]
      (->> (concat (interleave vars p) [o])
           (d/successive-nth 3 2))))

  (defn resolve-patterns
    [patterns]
    (mapcat
     (fn [[_ p :as t]]
       (if (vector? p)
         (resolve-path-pattern t)
         [t]))
     patterns))
#+END_SRC

**** Pattern generation

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn produce-patterns-with-bound-vars
    "Takes a triple pattern (possibly with variables) and a map of
    possible value sets (each *must* be a set or single value) for each var.
    Produces lazy seq of resulting triple query patterns using cartesian
    product of all values.

        (produce-patterns-with-bound-vars
          [?a :type ?b]
          {?a #{\"me\" \"you\"} ?b #{\"foo\" \"bar\"})
        => ((\"me\" :type \"foo\") (\"me\" :type \"bar\")
            (\"you\" :type \"foo\") (\"you\" :type \"bar\"))"
    [[s p o] bindings]
    (let [s (or (bindings s) s)
          p (or (bindings p) p)
          o (or (bindings o) o)]
      (if (some set? [s p o])
        (d/cartesian-product
         (if (set? s) s #{s}) (if (set? p) p #{p}) (if (set? o) o #{o}))
        [[s p o]])))
#+END_SRC

**** Query planning

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn sort-patterns
    "Sorts a seq of triple patterns in dependency order using any
    re-occuring vars. Triples with least qvars will be in head
    position."
    [patterns]
    (let [q (map #(let [v (d/filter-tree qvar? %)] [(count v) v %]) patterns)
          singles (->> q (filter #(= 1 (first %))) (mapcat second) set)]
      (->> q
           (sort-by (fn [[c v]] (- (* c 4) (count (filter singles v)))))
           (map peek))))
#+END_SRC

**** Pattern based triple verification

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn triple-verifier
    "Takes a triple pattern (potentially with vars) and 3 booleans to
    indicate which SPO is a var. Returns fn which accepts a result triple
    and returns false if any of the vars clash (e.g. a qvar is used multiple
    times but result has different values in each position or likewise, if
    different vars relate to same values)."
    [[ts tp to] vars varp varo]
    (cond
     (and vars varp varo) (cond
                           (= ts tp to) (fn [[rs rp ro]] (= rs rp ro))
                           (= ts tp) (fn [[rs rp ro]] (and (= rs rp) (not= rs ro)))
                           (= ts to) (fn [[rs rp ro]] (and (= rs ro) (not= rs rp)))
                           (= tp to) (fn [[rs rp ro]] (and (= rp ro) (not= rs rp)))
                           :default (constantly true))
     (and vars varp) (if (= ts tp)
                       (fn [[rs rp]] (= rs rp))
                       (fn [[rs rp]] (not= rs rp)))
     (and vars varo) (if (= ts to)
                       (fn [[rs _ ro]] (= rs ro))
                       (fn [[rs _ ro]] (not= rs ro)))
     (and varp varo) (if (= tp to)
                       (fn [[_ rp ro]] (= rp ro))
                       (fn [[_ rp ro]] (not= rp ro)))
     :default (constantly true)))
#+END_SRC

*** Result handling
#+BEGIN_SRC clojure :noweb-ref helpers
  (defn unique-bindings?
    "Returns true if all values in the given map are unique, i.e.
    no two keys are mapped to the same value."
    [map] (== (count (into #{} (vals map))) (count map)))

  (defn accumulate-result-vars
    "Takes a query result map seq and returns map of all found qvars
    as keys and their value sets."
    ([res] (accumulate-result-vars {} nil res))
    ([acc vars res]
       (let [acc (reduce
                  (fn [acc b]
                    (merge-with
                     (fn [a b] (if (set? a) (conj a b) (hash-set a b)))
                     acc (if vars (select-keys b vars) b)))
                  acc res)]
         (reduce-kv
          (fn [acc k v] (if (set? v) acc (assoc acc k #{v})))
          acc acc))))

  (defn select-renamed-keys
    "Similar to clojure.core/select-keys, but instead of key seq takes a
    map of keys to be renamed (keys in that map are the original keys to
    be selected, their values the renamed keys in returned map)."
    [ret map aliases]
    (loop [ret ret, keys aliases]
      (if keys
        (let [kv (first keys)
              entry (find map (key kv))]
          (recur
           (if entry
             (assoc ret (val kv) (val entry))
             ret)
           (next keys)))
        ret)))

  (defn order-asc
    [vars res]
    (if (coll? vars)
      (sort-by (fn [r] (reduce #(conj % (r %2)) [] vars)) res)
      (sort-by (fn [r] (get r vars)) res)))

  (defn order-desc
    [vars res]
    (if (coll? vars)
      (sort-by
       (fn [r] (reduce #(conj % (r %2)) [] vars))
       #(- (compare % %2))
       res)
      (sort-by #(get % vars) #(- (compare % %2)) res)))

  (defn distinct-result-set
    [res]
    (->> res
         (reduce
          (fn [acc r]
            (let [vs (set (vals r))]
              (if (acc vs) acc (assoc acc vs r))))
          {})
         (vals)))

  (defn keywordize-result-vars
    [res]
    (map
     (fn [r] (into {} (map (fn [[k v]] [(-> k qvar-name keyword) v]) r)))
     res))
#+END_SRC

*** Graphviz export
**** TODO move to separate ns

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn triples->dot
    "Takes a seq of triples and returns them as digraph spec in
    Graphviz .dot format."
    [triples]
    (apply
     str
     (concat
      "digraph G {\n"
      "node[color=\"black\",style=\"filled\",fontname=\"Inconsolata\",fontcolor=\"white\"];\n"
      "edge[fontname=\"Inconsolata\",fontsize=\"9\"];\n"
      (map
       (fn [t]
         (let [[s p o] (map #(if (string? %) % (pr-str %)) t)]
           (str "\"" s "\" -> \"" o "\" [label=\"" p "\"];\n")))
       triples)
      "}")))
#+END_SRC

** Joins

#+BEGIN_SRC clojure :noweb-ref joins
  (defn join
    [a b]
    (->> (set/join a b)
         (mapcat
          (fn [k]
            (if (unique-bindings? k)
              [k])))))

  (defn join-optional
    [a b]
    (loop [old (transient #{}), new (transient #{}), kb b]
      (if kb
        (let [kb' [(first kb)]
              [old new] (loop [old old, new new, ka a]
                          (if ka
                            (let [ka' (first ka)
                                  j (first (set/join [ka'] kb'))]
                              (if j
                                (recur (conj! old ka') (conj! new j) (next ka))
                                (recur old new (next ka))))
                            [old new]))]
          (recur old new (next kb)))
        (let [new (persistent! new)]
          (if (seq new)
            (into (apply disj (set a) (persistent! old)) new)
            a)))))

   (defn minus
     [a b]
     (let [vars (accumulate-result-vars b)]
       (reduce-kv
        (fn [res k v]
          (let [v (if (coll? v) v [v])]
            (reduce
             (fn [res v] (vec (remove (fn [r] (= (r k) v)) res))) res v)))
        a vars)))

   (defn union
     [a b] (set (concat a b)))
#+END_SRC

** Select

#+BEGIN_SRC clojure :noweb-ref selectors
  (defn unbound-var?
    [bindings v? x] (and v? (not (bindings x))))

  (defn bind-translator
    [vs? vp? vo? [s p o]]
    (if vs?
      (if vp?
        (if vo?
          (fn [[s' p' o']] {s s' p p' o o'})
          (fn [[s' p']] {s s' p p'}))
        (if vo?
          (fn [[s' _ o']] {s s' o o'})
          (fn [r] {s (first r)})))
      (if vp?
        (if vo?
          (fn [[_ p' o']] {p p' o o'})
          (fn [r] {p (r 1)}))
        (if vo?
          (fn [r] {o (r 2)})
          (fn [_] {})))))

  (defn unbound-vars-translator
    [bindings vs? vp? vo? [s p o]]
    (if (unbound-var? bindings vs? s)
      (if (unbound-var? bindings vp? p)
        (if (unbound-var? bindings vo? o)
          (fn [p] [nil nil nil])
          (fn [p] [nil nil (p 2)]))
        (if (unbound-var? bindings vo? o)
          (fn [p] [nil (p 1) nil])
          (fn [p] (assoc p 0 nil))))
      (if (unbound-var? bindings vp? p)
        (if (unbound-var? bindings vo? o)
          (fn [p] [(p 0) nil nil])
          (fn [p] (assoc p 1 nil)))
        (if (unbound-var? bindings vo? o)
          (fn [p] (assoc p 2 nil))
          identity))))

  (defn select-with-bindings
    [ds bindings opts [s p o :as t]]
    (let [patterns (produce-patterns-with-bound-vars t bindings)
          _        (prn :patterns patterns)
          vs?      (qvar? s), vp? (qvar? p), vo? (qvar? o)
          vmap     (bind-translator vs? vp? vo? t)
          pmap     (unbound-vars-translator bindings vs? vp? vo? t)
          verify   (triple-verifier t vs? vp? vo?)
          flt      (compile-filter-fn (opts :filter))
          res-fn   (if flt
                     #(if (verify %)
                        (let [vbinds (vmap %)]
                          (if (flt vbinds) vbinds)))
                     #(if (verify %) (vmap %)))]
      (loop [acc (transient []), ps patterns]
        (if ps
          (let [[qs qp qo] (pmap (vec (first ps)))
                _   (prn :select qs qp qo)
                res (api/select ds qs qp qo)]
            (if (seq res)
              (recur
               (loop [acc acc, res res]
                 (if res
                   (let [r (res-fn (first res))]
                     (if r
                       (recur (conj! acc r) (next res))
                       (recur acc (next res))))
                   acc))
               (next ps))
              (recur acc (next ps))))
          (persistent! acc)))))

  (defn select-join
    ([ds patterns]
       (select-join ds {} {} patterns))
    ([ds bindings {bind :bind flt :filter opt? :optional?} patterns]
       (let [[p & ps] (sort-patterns patterns)
             res      (select-with-bindings ds bindings {} p)
             join-fn  (if opt? join-optional join)
             flt      (compile-filter-fn flt)
             bind     (compile-bind-fn bind)]
         (if (seq res)
           (loop [res res, ps ps]
             (if ps
               (let [binds (merge-with into (accumulate-result-vars res) bindings)
                     r' (select-with-bindings ds binds {} (first ps))
                     res (if (seq r') (join-fn res r'))]
                 (if (seq res)
                   (recur res (next ps))))
               (cond->> res
                        flt (filter flt)
                        bind (map bind))))))))
#+END_SRC

** Transitive properties & path queries

If using equal min/max search depth, resort to =select-join= with
expanded pattern. In that case the predicate can be a seq =[pred1
pred2 ..]= which is expanded cyclically for =depth= hops, e.g:

 : (select-transitive ds '[?s [mother father] ?o] 3 3)

Else the fn takes a standard pattern with the subject or object either a given
constant or qvar:

Select all 'mother' rels from 1 - 3 hops (i.e. from mother -> great-grandmother)
 : (select-transitive ds '[?s mother ?c] 1 3)

If the object is not a qvar, the search is executed in reverse direction:
 : (select-transitive ds '[?m mother 'toxi])

Select only grandchildren for given person:
 : (select-transitive ds '[john father ?c] 2 2)
 : ;; same as...
 : (select-join ds '[[john father ?p] [?p father ?c]])
  
#+BEGIN_SRC clojure :noweb-ref dfs
  (defn subvec-slices
    "Takes a min & max count and returns function accepting a vector as
    single arg. When called, returns vector of subvec slices each starting
    at index 0 and with an increasing length from min to max."
    [n1 n2]
    (fn [path]
      (mapv #(subvec path 0 %) (range n1 (inc (min (count path) n2))))))

  (defn dfs-forward*
    [ds s p sv acc min max]
    (if (<= (count acc) max)
      (let [acc (conj acc sv)
            o (auto-qvar)
            r (select-with-bindings ds {s sv} {} [s p o])]
        (if (seq r)
          (let [visited (set acc)
                ovals (filter (comp not visited) (set (map o r)))]
            (if (seq ovals)
              (#+clj r/mapcat #+cljs mapcat
                     (fn [ov] (dfs-forward* ds o p ov acc min max))
                     ovals)
              [acc]))
          (if (> (count acc) min) [acc])))
      [acc]))

  (defn dfs-backward*
    [ds o p ov acc min max]
    (if (<= (count acc) max)
      (let [acc (conj acc ov)
            s (auto-qvar)
            r (select-with-bindings ds {o ov} {} [s p o])]
        (if (seq r)
          (let [visited (set acc)
                svals (filter (comp not visited) (set (map s r)))]
            (if (seq svals)
              (#+clj r/mapcat #+cljs mapcat
                     (fn [sv] (dfs-backward* ds s p sv acc min max))
                     svals)
              [acc]))
          (if (> (count acc) min) [acc])))
      [acc]))

  (defn select-transitive
    ([ds [s p o :as t]]
       (if (vector? p)
         (select-transitive ds t (count p) (count p))
         (select-transitive ds t 1 1000000)))
    ([ds [s p o] mind maxd]
       (let [mind (max mind 1)
             maxd (max maxd 1)]
         (if (= mind maxd)
           (let [p (if (vector? p) p [p])
                 p (take mind (cycle p))]
             (select-join ds {} {} (resolve-path-pattern [s p o])))
           (let [vs? (qvar? s)
                 vo? (qvar? o)
                 v (auto-qvar)
                 conf (cond
                       (and vs? vo?) {:s s ;; [?s p ?o]
                                      :o v
                                      :bmap {}
                                      :lookup (fn [b] [(b v) (b s)])
                                      :bind (fn [p] {s (first p) o (peek p)})
                                      :search dfs-forward*}
                       vo?           {:s v ;; [x p ?o]
                                      :o o
                                      :bmap {v s}
                                      :lookup (fn [b] [(b o) (b v)])
                                      :bind (fn [p] {o (peek p)})
                                      :search dfs-forward*}
                       vs?           {:s s ;; [?s p x]
                                      :o v
                                      :bmap {v o}
                                      :lookup (fn [b] [(b s) (b v)])
                                      :bind (fn [p] {s (peek p)})
                                      :search dfs-backward*})
                 {:keys [bind search]} conf
                 slices (subvec-slices (inc mind) (inc maxd))]
             (->> (select-with-bindings ds (:bmap conf) {} [(:s conf) p (:o conf)])
                  (r/map    (:lookup conf))
                  (r/mapcat #(search ds v p (% 0) [(% 1)] mind maxd))
                  (r/mapcat slices)
                  (r/map    bind)
                  (into #{})))))))
#+END_SRC

** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/query.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.query
    (:require
     [thi.ng.trio.core :as api]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.data.unionfind :as uf]
     [clojure.set :as set]
     [clojure.core.reducers :as r]))

  <<helpers>>

  <<joins>>

  <<selectors>>

  <<dfs>>

  <<compiler>>
#+END_SRC
