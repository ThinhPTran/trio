#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.query

** Highlevel query processing

*** Examples

#+BEGIN_SRC clojure
  (q/query
   {:select :*
    :from ds
    :query [{:join '[[?gf father ?f]
                     [?f father ?c]]}
            {:optional '[[?gm mother ?f]]}
            {:optional '[[?c age ?a]]}]
    :bind {'?a (fn [res a] (if a (str (res '?c) " is " a " years old")))}})

  (q/query
   {:construct '[[?gf grandfather ?c]
                 [?gm grandmother ?c]]
    :from ds
    :query [{:join '[[?gf father ?f]
                     [?gm mother ?f]
                     [?f father ?c]]}]})
#+END_SRC

*** Query compiler

#+BEGIN_SRC clojure :noweb-ref processor
  (defn query-opts
    [{:keys [filter bind]}]
    {:filter (if filter
               (if (fn? filter)
                 filter
                 (compile-filter-fn filter)))
     :bind   (if bind
               (if (fn? bind)
                 bind
                 (compile-bind-fn bind)))})

  (defn query-step
    [qfn join-fn q patterns]
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)
              b (select-join (:from q) {} opts patterns)
              res' (if (= ::empty a) b (join-fn a b))]
          res'))))

  (defmulti compile-query-step
    (fn [qfn q type] type))

  (defmethod compile-query-step :join
    [qfn {:keys [from where] :as q} _]
    (prn :join where)
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)]
          (if (or (= ::empty a) (seq a))
            (let [b (select-join from {} opts where)
                  res' (if (= ::empty a) b (join a b))]
              res')
            a)))))

  (defmethod compile-query-step :minus
    [qfn {:keys [from minus] :as q} _]
    (prn :minus minus)
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)]
          (if (seq a)
            (thi.ng.trio.query/minus a (select-join from {} opts minus))
            a)))))

  (defmethod compile-query-step :optional
    [qfn {:keys [from optional] :as q} _]
    (prn :join-opt optional)
    (query-step qfn join-optional q optional))

  (defmethod compile-query-step :union
    [qfn {:keys [from union] :as q} _]
    (prn :union union)
    (query-step qfn thi.ng.trio.query/union q union))

  (defmethod compile-query-step :multi-query
    [qfn {:keys [from query]} _]
    (prn :multi query)
    (loop [qfn qfn, query query]
      (if query
        (let [q (first query)
              q (if (:from q) q (assoc q :from from))
              qfn (cond
                   (:where q)    (compile-query-step qfn q :join)
                   (:optional q) (compile-query-step qfn q :optional)
                   (:minus q)    (compile-query-step qfn q :minus)
                   (:union q)    (compile-query-step qfn q :union))]
          (recur qfn (next query)))
        qfn)))

  (defmethod compile-query-step :bind
    [qfn bind _]
    (prn :bindings bind)
    (let [bind (if (fn? bind)
                 bind
                 (compile-bind-fn bind))]
      (fn [res] (map bind (qfn res)))))

  (defmethod compile-query-step :order-asc
    [qfn order _]
    (prn :order-asc order)
    (fn [res] (order-asc order (qfn res))))

  (defmethod compile-query-step :order-desc
    [qfn order _]
    (prn :order-desc order)
    (fn [res] (order-desc order (qfn res))))

  (defmethod compile-query-step :group
    [qfn group _]
    (prn :group group)
    (fn [res] (group-by group (qfn res))))

  (defmethod compile-query-step :filter-vars
    [qfn vars _]
    (prn :select-vars vars)
    (cond
     (= :* vars)        qfn
     (sequential? vars) (fn [res] (map #(select-keys % vars) (qfn res)))
     :else              (compile-query-step qfn [vars] :filter-vars)))

  (defmethod compile-query-step :select
    [qfn {:keys [select from query bind order-asc order-desc group] :as q} _]
    (prn :select select)
    (cond->
     (compile-query-step qfn q :multi-query)
     bind       (compile-query-step bind :bind)
     order-asc  (compile-query-step order-asc :order-asc)
     order-desc (compile-query-step order-desc :order-desc)
     true       (compile-query-step select :filter-vars)
     group      (compile-query-step group :group)))

  (defmethod compile-query-step :construct-triples
    [qfn {:keys [construct] :as q} _]
    (fn [res]
      (->> res
           qfn
           (mapcat
            (fn [r]
              (map
               (fn [[s p o]]
                 (let [s (if (qvar? s) (r s) s)
                       p (if (qvar? p) (r p) p)
                       o (if (qvar? o) (r o) o)]
                   (if (and s p o) (api/triple s p o))))
               construct)))
           (filter identity)
           (set))))

  (defmethod compile-query-step :construct
    [qfn q _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :group)
                (assoc :select :*))]
      (-> qfn
          (compile-query-step q :select)
          (compile-query-step q :construct-triples))))

  (defmethod compile-query-step :ask
    [qfn q _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :bind :group)
                (assoc :select :*))
          qfn (compile-query-step qfn q :select)]
      (fn [res] (if (seq (qfn res)) true false))))

  (defmethod compile-query-step :describe
    [qfn {:keys [from describe] :as q} _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :group)
                (assoc :select :*))
          qfn (compile-query-step qfn q :select)
          describe (if (sequential? describe) describe [describe])]
      (fn [res]
        (let [res (qfn res)
              vars (select-keys (accumulate-result-vars res) describe)]
          (if (seq vars)
            (mapcat
             (fn [v]
               (let [vals (vars v)
                     vals (if (coll? vals) vals [vals])]
                 (mapcat #(api/select from % nil nil) vals)))
             (keys vars)))))))

  (defn compile-query
    [q]
    (if-let [type (some #{:select :ask :construct :describe} (keys q))]
      (compile-query-step identity q type)
      (err/unsupported! "Unsupported query type")))

  (defn query
    [q] ((if (fn? q) q (compile-query q)) ::empty))
#+END_SRC

** Helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn trace [id _] (dorun _) (prn id _) _)
#+END_SRC

*** Query variables
#+BEGIN_SRC clojure :noweb-ref helpers
  (def ^:dynamic *auto-qvar-prefix* "?__q")

  (defn qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (re-matches #"^\?.*" (name x))))

  (defn auto-qvar?
    "Returns true, if x is an auto-generated qvar
    (a symbol prefixed with *auto-qvar-prefix*)"
    [x] (and (symbol? x) (zero? (.indexOf ^String (name x) *auto-qvar-prefix*))))

  (defn auto-qvar
    "Creates a new auto-named qvar (symbol)."
    [] (gensym *auto-qvar-prefix*))

  (defn qvar-name
    [x] (-> x name (subs 1)))
#+END_SRC

*** Query pattern resolution & handling
#+BEGIN_SRC clojure :noweb-ref helpers
  (defn resolve-path-pattern
    "Takes a path triple pattern where the predicate is a seq of preds.
    Returns seq of query patterns with injected temp qvars for inbetween
    patterns. E.g.

        [?s [p1 p2 p3] ?o]
        => ([?s p1 ?__q0] [?__q0 p2 ?__q1] [?__q1 p3 ?o])"
    [[s p o]]
    (let [vars (->> auto-qvar
                    (repeatedly (dec (count p)))
                    (cons s))]
      (->> (concat (interleave vars p) [o])
           (d/successive-nth 3 2))))

  (defn resolve-patterns
    [patterns]
    (mapcat
     (fn [[_ p :as t]]
       (if (vector? p)
         (resolve-path-pattern t)
         [t]))
     patterns))

  ;; [?s [a b :+] ?o] - [?s [a b] ?o] min 1 max 1e6
  ;; [?s [a b :^] ?o] - [?o [b a] ?s] 

  (defn produce-patterns-with-bound-vars
    "Takes a triple pattern (possibly with variables) and a map of
    possible value sets (each *must* be a set or single value) for each var.
    Produces lazy seq of resulting triple query patterns using cartesian
    product of all values.

        (produce-patterns-with-bound-vars
          [?a :type ?b]
          {?a #{\"me\" \"you\"} ?b #{\"foo\" \"bar\"})
        => ((\"me\" :type \"foo\") (\"me\" :type \"bar\")
            (\"you\" :type \"foo\") (\"you\" :type \"bar\"))"
    [[s p o] bindings]
    (let [s (or (bindings s) s)
          p (or (bindings p) p)
          o (or (bindings o) o)]
      (if (some set? [s p o])
        (d/cartesian-product
         (if (set? s) s #{s}) (if (set? p) p #{p}) (if (set? o) o #{o}))
        [[s p o]])))

  (defn sort-patterns
    "Sorts a seq of triple patterns in dependency order using any
    re-occuring vars. Triples with least qvars will be in head
    position."
    [patterns]
    (let [q (map #(let [v (d/filter-tree qvar? %)] [(count v) v %]) patterns)
          singles (->> q (filter #(= 1 (first %))) (mapcat second) set)]
      (->> q
           (sort-by (fn [[c v]] (- (* c 4) (count (filter singles v)))))
           (map peek))))

  (defn triple-verifier
    "Takes a triple pattern (potentially with vars) and 3 booleans to
    indicate which SPO is a var. Returns fn which accepts a result triple
    and returns false if any of the vars clash (e.g. a qvar is used multiple
    times but result has different values in each position or likewise, if
    different vars relate to same values)."
    [[ts tp to] vars varp varo]
    (cond
     (and vars varp varo) (cond
                           (= ts tp to) (fn [[rs rp ro]] (= rs rp ro))
                           (= ts tp) (fn [[rs rp ro]] (and (= rs rp) (not= rs ro)))
                           (= ts to) (fn [[rs rp ro]] (and (= rs ro) (not= rs rp)))
                           (= tp to) (fn [[rs rp ro]] (and (= rp ro) (not= rs rp)))
                           :default (constantly true))
     (and vars varp) (if (= ts tp)
                       (fn [[rs rp]] (= rs rp))
                       (fn [[rs rp]] (not= rs rp)))
     (and vars varo) (if (= ts to)
                       (fn [[rs _ ro]] (= rs ro))
                       (fn [[rs _ ro]] (not= rs ro)))
     (and varp varo) (if (= tp to)
                       (fn [[_ rp ro]] (= rp ro))
                       (fn [[_ rp ro]] (not= rp ro)))
     :default (constantly true)))
#+END_SRC

*** Result handling
#+BEGIN_SRC clojure :noweb-ref helpers
  (defn unique-bindings?
    "Returns true if all values in the given map are unique, i.e.
    no two keys are mapped to the same value."
    [map] (== (count (into #{} (vals map))) (count map)))

  (defn accumulate-result-vars
    "Takes a query result map seq and returns map of all found qvars
    as keys and their value sets."
    ([res] (accumulate-result-vars {} nil res))
    ([acc vars res]
       (reduce
        (fn [acc b]
          (merge-with
           (fn [a b] (if (set? a) (conj a b) (hash-set a b)))
           acc (if vars (select-keys b vars) b)))
        acc res)))

  (defn select-renamed-keys
    "Similar to clojure.core/select-keys, but instead of key seq takes a
    map of keys to be renamed (keys in that map are the original keys to
    be selected, their values the renamed keys in returned map)."
    [ret map aliases]
    (loop [ret ret, keys aliases]
      (if keys
        (let [kv (first keys)
              entry (find map (key kv))]
          (recur
           (if entry
             (assoc ret (val kv) (val entry))
             ret)
           (next keys)))
        ret)))

  (defn order-asc
    [vars res]
    (if (coll? vars)
      (sort-by (fn [r] (reduce #(conj % (r %2)) [] vars)) res)
      (sort-by (fn [r] (get r vars)) res)))

  (defn order-desc
    [vars res]
    (if (coll? vars)
      (sort-by
       (fn [r] (reduce #(conj % (r %2)) [] vars))
       #(- (compare % %2))
       res)
      (sort-by #(get % vars) #(- (compare % %2)) res)))

  (defn distinct-result-set
    [res]
    (->> res
         (reduce
          (fn [acc r]
            (let [vs (set (vals r))]
              (if (acc vs) acc (assoc acc vs r))))
          {})
         (vals)))

  (defn keywordize-result-vars
    [res]
    (map
     (fn [r] (into {} (map (fn [[k v]] [(-> k qvar-name keyword) v]) r)))
     res))

  (defn compile-filter-fn
   [filters]
   (fn [res] (every? (fn [[k f]] (if-let [rv (res k)] (f rv) true)) filters)))

  (defn compile-bind-fn
   [bindings]
   (fn [res] (reduce-kv (fn [acc k f] (assoc acc k (f res (res k)))) res bindings)))
#+END_SRC

*** Graphviz export
#+BEGIN_SRC clojure :noweb-ref helpers
  (defn triples->dot
    "Takes a seq of triples and returns them as digraph spec in
    Graphviz .dot format."
    [triples]
    (apply
     str
     (concat
      "digraph G {\n"
      "node[color=\"black\",style=\"filled\",fontname=\"Inconsolata\",fontcolor=\"white\"];\n"
      "edge[fontname=\"Inconsolata\",fontsize=\"9\"];\n"
      (map
       (fn [t]
         (let [[s p o] (map #(if (string? %) % (pr-str %)) t)]
           (str "\"" s "\" -> \"" o "\" [label=\"" p "\"];\n")))
       triples)
      "}")))
#+END_SRC

** Joins

#+BEGIN_SRC clojure :noweb-ref joins
  (defn join
    [a b]
    (->> (set/join a b)
         (mapcat
          (fn [k]
            (if (unique-bindings? k)
              [k])))))

  (defn join-optional
    [a b]
    (loop [old (transient #{}), new (transient #{}), kb b]
      (if kb
        (let [kb' [(first kb)]
              [old new] (loop [old old, new new, ka a]
                          (if ka
                            (let [ka' (first ka)
                                  j (first (set/join [ka'] kb'))]
                              (if j
                                (recur (conj! old ka') (conj! new j) (next ka))
                                (recur old new (next ka))))
                            [old new]))]
          (recur old new (next kb)))
        (let [new (persistent! new)]
          (if (seq new)
            (into (apply disj (set a) (persistent! old)) new)
            a)))))

   (defn minus
     [a b]
     (let [vars (accumulate-result-vars b)]
       (reduce-kv
        (fn [res k v]
          (let [v (if (coll? v) v [v])]
            (reduce
             (fn [res v] (vec (remove (fn [r] (= (r k) v)) res))) res v)))
        a vars)))

   (defn union
     [a b] (set (concat a b)))
#+END_SRC

** Select

#+BEGIN_SRC clojure :noweb-ref selectors
  (defn unbound-var?
    [bindings v? x] (and v? (not (bindings x))))

  (defn bind-translator
    [vs? vp? vo? [s p o]]
    (if vs?
      (if vp?
        (if vo?
          (fn [[s' p' o']] {s s' p p' o o'})
          (fn [[s' p']] {s s' p p'}))
        (if vo?
          (fn [[s' _ o']] {s s' o o'})
          (fn [r] {s (first r)})))
      (if vp?
        (if vo?
          (fn [[_ p' o']] {p p' o o'})
          (fn [r] {p (r 1)}))
        (if vo?
          (fn [r] {o (r 2)})
          (fn [_] {})))))

  (defn unbound-vars-translator
    [bindings vs? vp? vo? [s p o]]
    (if (unbound-var? bindings vs? s)
      (if (unbound-var? bindings vp? p)
        (if (unbound-var? bindings vo? o)
          (fn [p] [nil nil nil])
          (fn [p] [nil nil (p 2)]))
        (if (unbound-var? bindings vo? o)
          (fn [p] [nil (p 1) nil])
          (fn [p] (assoc p 0 nil))))
      (if (unbound-var? bindings vp? p)
        (if (unbound-var? bindings vo? o)
          (fn [p] [(p 0) nil nil])
          (fn [p] (assoc p 1 nil)))
        (if (unbound-var? bindings vo? o)
          (fn [p] (assoc p 2 nil))
          identity))))

  (defn select-with-bindings
    [ds bindings opts [s p o :as t]]
    (let [patterns (produce-patterns-with-bound-vars t bindings)
          ;; _ (prn :patterns patterns)
          vs? (qvar? s), vp? (qvar? p), vo? (qvar? o)
          vmap (bind-translator vs? vp? vo? t)
          pmap (unbound-vars-translator bindings vs? vp? vo? t)
          verify (triple-verifier t vs? vp? vo?)
          flt (opts :filter)
          res-fn (if flt
                   (let [flt (if (map? flt) (compile-filter-fn flt) flt)]
                     #(if (verify %)
                        (let [vbinds (vmap %)]
                          (if (flt vbinds) vbinds))))
                   #(if (verify %) (vmap %)))]
      (loop [acc (transient []), ps patterns]
        (if ps
          (let [[qs qp qo] (pmap (vec (first ps)))
                ;; _ (prn :select qs qp qo)
                res (api/select ds qs qp qo)]
            (if (seq res)
              (recur
               (loop [acc acc, res res]
                 (if res
                   (let [r (res-fn (first res))]
                     (if r
                       (recur (conj! acc r) (next res))
                       (recur acc (next res))))
                   acc))
               (next ps))
              (recur acc (next ps))))
          (persistent! acc)))))

  (defn select-join
    ([ds patterns]
       (select-join ds {} {} patterns))
    ([ds bindings {bind :bind flt :filter opt? :optional?} patterns]
       (let [[p & ps] (sort-patterns patterns)
             res      (select-with-bindings ds bindings {} p)
             join-fn  (if opt? join-optional join)
             flt      (if (map? flt) (compile-filter-fn flt) flt)
             bind     (if (map? bind) (compile-bind-fn bind) bind)]
         (if (seq res)
           (loop [res res, ps ps]
             (if ps
               (let [r' (select-with-bindings ds (accumulate-result-vars res) {} (first ps))
                     res (if (seq r') (join-fn res r'))]
                 (if (seq res)
                   (recur res (next ps))))
               (cond->> res
                        flt (filter flt)
                        bind (map bind))))))))
#+END_SRC

** Transitive properties & path queries

If same min/max search depth, resort to =select-join= with expanded pattern.
In that case predicate can be a seq =[pred1 pred2 ..]= which is
expanded cyclically for =depth= hops, e.g:

 : (select-transitive ds '[?s [mother father] ?o] 3 3)

Else the fn takes a standard pattern with the subject or object either a given
constant or qvar:

Select all 'mother' rels from 1 - 3 hops (i.e. from mother -> great-grandmother)
 : (select-transitive ds '[?s mother ?c] 1 3)

If the object is not a qvar, the search is executed in reverse direction:
 : (select-transitive ds '[?m mother 'toxi])

Select only children & grandchildren for given person:
 : (select-transitive ds '[john father ?c] 2 2)
 : ;; same as...
 : (select-join ds '[[john father ?p] [?p father ?c]])

*** TODO Specifying variable length paths

- http://www.w3.org/TR/sparql11-query/#propertypaths

#+BEGIN_SRC clojure :noweb-ref dfs
  (defn subvec-slices
    "Takes a min & max count and returns function accepting a vector as
    single arg. When called, returns vector of subvec slices each starting
    at index 0 and with an increasing length from min to max."
    [n1 n2]
    (fn [path]
      (mapv #(subvec path 0 %) (range n1 (inc (min (count path) n2))))))

  (defn dfs-forward*
    [ds s p sv acc min max]
    (if (<= (count acc) max)
      (let [acc (conj acc sv)
            o (auto-qvar)
            r (select-with-bindings ds {s sv} {} [s p o])]
        (if (seq r)
          (let [visited (set acc)
                ovals (filter (comp not visited) (set (map o r)))]
            (if (seq ovals)
              (#+clj r/mapcat #+cljs mapcat
                     (fn [ov] (dfs-forward* ds o p ov acc min max))
                     ovals)
              [acc]))
          (if (> (count acc) min) [acc])))
      [acc]))

  (defn dfs-backward*
    [ds o p ov acc min max]
    (if (<= (count acc) max)
      (let [acc (conj acc ov)
            s (auto-qvar)
            r (select-with-bindings ds {o ov} {} [s p o])]
        (if (seq r)
          (let [visited (set acc)
                svals (filter (comp not visited) (set (map s r)))]
            (if (seq svals)
              (#+clj r/mapcat #+cljs mapcat
                     (fn [sv] (dfs-backward* ds s p sv acc min max))
                     svals)
              [acc]))
          (if (> (count acc) min) [acc])))
      [acc]))

  (defn select-transitive
    ([ds [s p o :as t]]
       (if (vector? p)
         (select-transitive ds t (count p) (count p))
         (select-transitive ds t 1 1000000)))
    ([ds [s p o] mind maxd]
       (let [mind (max mind 1)
             maxd (max maxd 1)]
         (if (= mind maxd)
           (let [p (if (vector? p) p [p])
                 p (take mind (cycle p))]
             (select-join ds {} {} (resolve-path-pattern [s p o])))
           (let [vs? (qvar? s)
                 vo? (qvar? o)
                 v (auto-qvar)
                 conf (cond
                       (and vs? vo?) {:s s ;; [?s p ?o]
                                      :o v
                                      :bmap {}
                                      :lookup (fn [b] [(b v) (b s)])
                                      :bind (fn [p] {s (first p) o (peek p)})
                                      :search dfs-forward*}
                       vo?           {:s v ;; [x p ?o]
                                      :o o
                                      :bmap {v s}
                                      :lookup (fn [b] [(b o) (b v)])
                                      :bind (fn [p] {o (peek p)})
                                      :search dfs-forward*}
                       vs?           {:s s ;; [?s p x]
                                      :o v
                                      :bmap {v o}
                                      :lookup (fn [b] [(b s) (b v)])
                                      :bind (fn [p] {s (peek p)})
                                      :search dfs-backward*})
                 {:keys [bind search]} conf
                 slices (subvec-slices (inc mind) (inc maxd))]
             (->> (select-with-bindings ds (:bmap conf) {} [(:s conf) p (:o conf)])
                  (r/map    (:lookup conf))
                  (r/mapcat #(search ds v p (% 0) [(% 1)] mind maxd))
                  (r/mapcat slices)
                  (r/map    bind)
                  (into #{})))))))
#+END_SRC

** Examples

#+BEGIN_SRC clojure
  (q/join
   (q/select-transitive ds '[?gp mother ?c])
   (q/select-with-bindings ds '[?sp spouse ?c]))

  (require
   '[thi.ng.trio.core :refer :all]
   '[thi.ng.trio.query2 :as q])

  (def ds (apply plain-store (read-string (slurp "../dev/schmidts.clj"))))

  (spit "schmidts.dot" (q/results->dot (q/select-transitive ds '[?s [mother father] ?c])))
#+END_SRC

** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/query.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.query
    (:require
     [thi.ng.trio.core :as api]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.data.unionfind :as uf]
     [clojure.set :as set]
     [clojure.core.reducers :as r]))

  <<helpers>>

  <<joins>>

  <<selectors>>

  <<dfs>>

  <<processor>>
#+END_SRC
