#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.query

** Highlevel query processing

Triple stores not just provide high flexibility in terms of data
organization and storage, but also for querying purposes. The query
engine implemented in this namespace is conceptually based on [[http://www.w3.org/TR/sparql11-query][SPARQL]],
however does not entail any RDF specifics or semantics. Datalog (as
used by Datomic) too is similar in approach and both are essentially
based on describing & matching patterns in a directed graph.

*** Query engine features

| *Feature*                         | *Status*   |
|-----------------------------------+------------|
| Query planning                    | INPROGRESS |
| Query compilation                 | DONE       |
| Subqueries                        | DONE       |
| Multi-graph queries               | DONE       |
| Filtering (per sub-query)         | DONE       |
| Joins (fail fast)                 | DONE       |
| Optional joins                    | DONE       |
| Union                             | DONE       |
| Subtraction                       | DONE       |
| Arbitrary-length property paths   | INPROGRESS |
| Result graph construction         | DONE       |
| Result graph extraction           | DONE       |
| Result var binding injection      | DONE       |
| Result ordering on arbitrary vars | DONE       |
| Result grouping                   | DONE       |

*** Examples

To introduce some of the query engine features, let's define a small graph of relationships:

#+NAME: example-graph-table
| *Subject* | *Predicate* | *Object* |
|-----------+-------------+----------|
| alice     | friend      | bob      |
| alice     | age         | 34       |
| bob       | friend      | carl     |
| bob       | nick        | bobby    |
| carl      | spouse      | alice    |
| carl      | father      | donald   |
| carl      | age         | 42       |
| bob       | father      | emily    |
| emily     | age         | 23       |
| freya     | mother      | emily    |
| emily     | nick        | em       |
| donald    | friend      | emily    |

#+BEGIN_SRC dot :noweb yes :file ../assets/query-example01.png :exports results
  digraph G {
    node[color="black",style="filled",fontname="Inconsolata",fontcolor="white",fontsize="11"];
    edge[fontname="Inconsolata",fontsize="9"];
    <<lob-make-dot(graph-table=example-graph-table)>>
  }
#+END_SRC

[[../assets/query-example01.png]]

In Clojure this graph would be defined like this:

#+BEGIN_SRC clojure
  (require '[thi.ng.trio.core :refer :all])
  (require '[thi.ng.trio.query :as q])

  (def g
    (->>
     '[[alice   friend  bob]
       [alice   age     34]
       [bob     friend  carl]
       [bob     nick    bobby]
       [carl    spouse  alice]
       [carl    father  donald]
       [carl    age     42]
       [bob     father  emily]
       [emily   age     23]
       [freya   mother  emily]
       [emily   nick    em]
       [donald  friend  emily]]
     (apply plain-store)))
#+END_SRC

**** Selection

Now let's query this graph to find some information about all parents & children:

- perform alternative queries to bind =?p= to fathers or mothers of any child =?c=
- optionally retrieve child's age =?a=
- inject result var binding/mapper to format age as descriptive string
- sort results by child name

#+BEGIN_SRC clojure
  (q/query
   {:select :*
    :from g
    :query [{:where '[[?p father ?c]]}
            {:union '[[?p mother ?c]]}
            {:optional '[[?c age ?a]]}]
    :bind {'?a (fn [res a] (if a (str (res '?c) " is " a " years old")))}
    :order-asc '?c})

  ;; => ({?p carl, ?c donald} {?a "emily is 23 years old", ?p freya, ?c emily} {?a "emily is 23 years old", ?p bob, ?c emily})
#+END_SRC

**** Graph construction / inference

Since we know Carl's spouse is Alice, but we don't have explicity
stated her as Donald's mother, we could create a query that produces
inferred facts based on these rules:

1. for every =?f= father of =?c= and where =?m= spouse of =?f=, we declare =?m= mother of =?c=
2. for every =?m= mother of =?c= and where =?f= spouse of =?m=, we declare =?f= father of =?c=
3. for every =?f= father of =?c= and =?m= mother of =?c=, we declare =?f= spouse =?m= (and vice versa)
4. declare a new =parent= relationship for each father/mother
5. declare a new =child-of= relationship for each child

In order to create these new facts we can use a =:construct= type query and we will also compile it first:

#+BEGIN_SRC clojure
  (def infer-parents
    (q/compile-query
     {:from g
      :construct '[[?f spouse ?m] [?m spouse ?f] [?f father ?c] [?m mother ?c]
                   [?f parent ?c] [?m parent ?c] [?c child-of ?f] [?c child-of ?m]]
      :query [{:where '[[?f father ?c] [?f spouse ?m]]}
              {:union '[[?m mother ?c] [?m spouse ?f]]}
              {:union '[[?f father ?c] [?m mother ?c]]}]}))

  (q/query infer-parents)

  ;; => #{[freya spouse bob] [carl father donald] [freya mother emily] [alice mother donald]
  ;;      [bob spouse freya] [carl spouse alice] [bob father emily] [alice spouse carl]}
#+END_SRC

Now we can add these inferred triples to our graph and test it:

#+BEGIN_SRC clojure
  (def g2 (add-bulk g (q/query infer-parents)))

  (q/query {:select :* :from g2 :query [{:where '[[?p parent ?c]]}] :group '?c})

  ;; => {emily [{?p bob, ?c emily} {?p freya, ?c emily}], donald [{?p carl, ?c donald} {?p alice, ?c donald}]}
#+END_SRC

The new graph with inferred triples marked in red:

[[../assets/query-example02.png]]

**** Subgraph extraction

As a final introductory example, let's demonstrate how to extract
anything we know about subjects matched via an initial query/search,
in this case people with nicknames and who are younger than 40. A
=:describe= query returns all triples in which a bound result var is
either a subject or object.

#+BEGIN_SRC clojure
  (q/query {:describe '?p :from g2 :query [{:where '[[?p nick ?n] [?p age ?a]] :filter {'?a #(< % 40)}}]})

  ;; => #{[emily child-of bob] [emily child-of freya] [emily nick em] [emily age 23]
  ;;      [donald friend emily] [freya mother emily] [freya parent emily] [bob parent emily] [bob father emily]}
#+END_SRC

The extracted sub-graph defined by the result triples (edges in red are the matched query terms):

[[../assets/query-example03.png]]

** Query compiler

#+BEGIN_SRC clojure :noweb-ref processor
  (defn query-opts
    [{:keys [filter bind]}]
    {:filter (if filter
               (if (fn? filter)
                 filter
                 (compile-filter-fn filter)))
     :bind   (if bind
               (if (fn? bind)
                 bind
                 (compile-bind-fn bind)))})

  (defn query-step
    [qfn join-fn {:keys [from with] :as q} patterns]
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)
              b (select-join from with opts patterns)
              res' (if (= ::empty a) b (join-fn a b))]
          res'))))

  (defmulti compile-query-step
    (fn [qfn q type] type))

  (defmethod compile-query-step :join
    [qfn {:keys [from with where] :as q} _]
    (prn :join where with)
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)]
          (if (or (= ::empty a) (seq a))
            (let [b (select-join from with opts where)
                  res' (if (= ::empty a) b (join a b))]
              res')
            a)))))

  (defmethod compile-query-step :minus
    [qfn {:keys [from with minus] :as q} _]
    (prn :minus minus with)
    (let [opts (query-opts q)]
      (fn [res]
        (let [a (qfn res)]
          (if (seq a)
            (thi.ng.trio.query/minus a (select-join from with opts minus))
            a)))))

  (defmethod compile-query-step :optional
    [qfn {:keys [from with optional] :as q} _]
    (prn :join-opt optional with)
    (query-step qfn join-optional q optional))

  (defmethod compile-query-step :union
    [qfn {:keys [from with union] :as q} _]
    (prn :union union with)
    (query-step qfn thi.ng.trio.query/union q union))

  (defmethod compile-query-step :multi-query
    [qfn {:keys [from with query]} _]
    (prn :multi query)
    (loop [qfn qfn, query query]
      (if query
        (let [q (first query)
              q (if (:from q) q (assoc q :from from))
              q (if (:with q) q (assoc q :with (or with {})))
              qfn (cond
                   (:where q)    (compile-query-step qfn q :join)
                   (:optional q) (compile-query-step qfn q :optional)
                   (:minus q)    (compile-query-step qfn q :minus)
                   (:union q)    (compile-query-step qfn q :union))]
          (recur qfn (next query)))
        qfn)))

  (defmethod compile-query-step :bind
    [qfn bind _]
    (prn :bindings bind)
    (let [bind (if (fn? bind)
                 bind
                 (compile-bind-fn bind))]
      (fn [res] (map bind (qfn res)))))

  (defmethod compile-query-step :order-asc
    [qfn order _]
    (prn :order-asc order)
    (fn [res] (order-asc order (qfn res))))

  (defmethod compile-query-step :order-desc
    [qfn order _]
    (prn :order-desc order)
    (fn [res] (order-desc order (qfn res))))

  (defmethod compile-query-step :group
    [qfn group _]
    (prn :group group)
    (fn [res] (group-by group (qfn res))))

  (defmethod compile-query-step :filter-vars
    [qfn vars _]
    (prn :select-vars vars)
    (cond
     (= :* vars)        qfn
     (sequential? vars) (fn [res] (map #(select-keys % vars) (qfn res)))
     :else              (compile-query-step qfn [vars] :filter-vars)))

  (defmethod compile-query-step :select
    [qfn {:keys [select from query bind order-asc order-desc group] :as q} _]
    (prn :select select)
    (cond->
     (compile-query-step qfn q :multi-query)
     bind       (compile-query-step bind :bind)
     order-asc  (compile-query-step order-asc :order-asc)
     order-desc (compile-query-step order-desc :order-desc)
     true       (compile-query-step select :filter-vars)
     group      (compile-query-step group :group)))

  (defmethod compile-query-step :construct-triples
    [qfn {:keys [construct] :as q} _]
    (fn [res]
      (->> res
           qfn
           (mapcat
            (fn [r]
              (map
               (fn [[s p o]]
                 (let [s (if (qvar? s) (r s) s)
                       p (if (qvar? p) (r p) p)
                       o (if (qvar? o) (r o) o)]
                   (if (and s p o) (api/triple s p o))))
               construct)))
           (filter identity)
           (set))))

  (defmethod compile-query-step :construct
    [qfn q _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :group)
                (assoc :select :*))]
      (-> qfn
          (compile-query-step q :select)
          (compile-query-step q :construct-triples))))

  (defmethod compile-query-step :ask
    [qfn q _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :bind :group)
                (assoc :select :*))
          qfn (compile-query-step qfn q :select)]
      (fn [res] (if (seq (qfn res)) true false))))

  (defmethod compile-query-step :describe
    [qfn {:keys [from describe] :as q} _]
    (let [q (-> q
                (dissoc :order-asc :order-desc :group)
                (assoc :select :*))
          qfn (compile-query-step qfn q :select)
          describe (if (sequential? describe) describe [describe])]
      (fn [res]
        (let [res (qfn res)
              vars (select-keys (accumulate-result-vars res) describe)]
          (if (seq vars)
            (reduce
             (fn [acc v]
               (let [vals (vars v)]
                 (-> acc
                     (into (mapcat #(api/select from % nil nil) vals))
                     (into (mapcat #(api/select from nil nil %) vals)))))
             #{} (keys vars)))))))

  (defn compile-query
    [q]
    (if-let [type (some #{:select :ask :construct :describe} (keys q))]
      (compile-query-step identity q type)
      (err/unsupported! "Unsupported query type")))

  (defn query
    [q] ((if (fn? q) q (compile-query q)) ::empty))
#+END_SRC

** Helpers
*** Query variables
#+BEGIN_SRC clojure :noweb-ref helpers
  (def ^:dynamic *auto-qvar-prefix* "?__q")

  (defn qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (re-matches #"^\?.*" (name x))))

  (defn auto-qvar?
    "Returns true, if x is an auto-generated qvar
    (a symbol prefixed with *auto-qvar-prefix*)"
    [x] (and (symbol? x) (zero? (.indexOf ^String (name x) *auto-qvar-prefix*))))

  (defn auto-qvar
    "Creates a new auto-named qvar (symbol)."
    [] (gensym *auto-qvar-prefix*))

  (defn qvar-name
    [x] (-> x name (subs 1)))
#+END_SRC

*** Query pattern resolution & handling
#+BEGIN_SRC clojure :noweb-ref helpers
  (defn resolve-path-pattern
    "Takes a path triple pattern where the predicate is a seq of preds.
    Returns seq of query patterns with injected temp qvars for inbetween
    patterns. E.g.

        [?s [p1 p2 p3] ?o]
        => ([?s p1 ?__q0] [?__q0 p2 ?__q1] [?__q1 p3 ?o])"
    [[s p o]]
    (let [vars (->> auto-qvar
                    (repeatedly (dec (count p)))
                    (cons s))]
      (->> (concat (interleave vars p) [o])
           (d/successive-nth 3 2))))

  (defn resolve-patterns
    [patterns]
    (mapcat
     (fn [[_ p :as t]]
       (if (vector? p)
         (resolve-path-pattern t)
         [t]))
     patterns))

  ;; [?s [a b :+] ?o] - [?s [a b] ?o] min 1 max 1e6
  ;; [?s [a b :^] ?o] - [?o [b a] ?s] 

  (defn produce-patterns-with-bound-vars
    "Takes a triple pattern (possibly with variables) and a map of
    possible value sets (each *must* be a set or single value) for each var.
    Produces lazy seq of resulting triple query patterns using cartesian
    product of all values.

        (produce-patterns-with-bound-vars
          [?a :type ?b]
          {?a #{\"me\" \"you\"} ?b #{\"foo\" \"bar\"})
        => ((\"me\" :type \"foo\") (\"me\" :type \"bar\")
            (\"you\" :type \"foo\") (\"you\" :type \"bar\"))"
    [[s p o] bindings]
    (let [s (or (bindings s) s)
          p (or (bindings p) p)
          o (or (bindings o) o)]
      (if (some set? [s p o])
        (d/cartesian-product
         (if (set? s) s #{s}) (if (set? p) p #{p}) (if (set? o) o #{o}))
        [[s p o]])))

  (defn sort-patterns
    "Sorts a seq of triple patterns in dependency order using any
    re-occuring vars. Triples with least qvars will be in head
    position."
    [patterns]
    (let [q (map #(let [v (d/filter-tree qvar? %)] [(count v) v %]) patterns)
          singles (->> q (filter #(= 1 (first %))) (mapcat second) set)]
      (->> q
           (sort-by (fn [[c v]] (- (* c 4) (count (filter singles v)))))
           (map peek))))

  (defn triple-verifier
    "Takes a triple pattern (potentially with vars) and 3 booleans to
    indicate which SPO is a var. Returns fn which accepts a result triple
    and returns false if any of the vars clash (e.g. a qvar is used multiple
    times but result has different values in each position or likewise, if
    different vars relate to same values)."
    [[ts tp to] vars varp varo]
    (cond
     (and vars varp varo) (cond
                           (= ts tp to) (fn [[rs rp ro]] (= rs rp ro))
                           (= ts tp) (fn [[rs rp ro]] (and (= rs rp) (not= rs ro)))
                           (= ts to) (fn [[rs rp ro]] (and (= rs ro) (not= rs rp)))
                           (= tp to) (fn [[rs rp ro]] (and (= rp ro) (not= rs rp)))
                           :default (constantly true))
     (and vars varp) (if (= ts tp)
                       (fn [[rs rp]] (= rs rp))
                       (fn [[rs rp]] (not= rs rp)))
     (and vars varo) (if (= ts to)
                       (fn [[rs _ ro]] (= rs ro))
                       (fn [[rs _ ro]] (not= rs ro)))
     (and varp varo) (if (= tp to)
                       (fn [[_ rp ro]] (= rp ro))
                       (fn [[_ rp ro]] (not= rp ro)))
     :default (constantly true)))
#+END_SRC

*** Result handling
#+BEGIN_SRC clojure :noweb-ref helpers
  (defn unique-bindings?
    "Returns true if all values in the given map are unique, i.e.
    no two keys are mapped to the same value."
    [map] (== (count (into #{} (vals map))) (count map)))

  (defn accumulate-result-vars
    "Takes a query result map seq and returns map of all found qvars
    as keys and their value sets."
    ([res] (accumulate-result-vars {} nil res))
    ([acc vars res]
       (let [acc (reduce
                  (fn [acc b]
                    (merge-with
                     (fn [a b] (if (set? a) (conj a b) (hash-set a b)))
                     acc (if vars (select-keys b vars) b)))
                  acc res)]
         (reduce-kv
          (fn [acc k v] (if (set? v) acc (assoc acc k #{v})))
          acc acc))))

  (defn select-renamed-keys
    "Similar to clojure.core/select-keys, but instead of key seq takes a
    map of keys to be renamed (keys in that map are the original keys to
    be selected, their values the renamed keys in returned map)."
    [ret map aliases]
    (loop [ret ret, keys aliases]
      (if keys
        (let [kv (first keys)
              entry (find map (key kv))]
          (recur
           (if entry
             (assoc ret (val kv) (val entry))
             ret)
           (next keys)))
        ret)))

  (defn order-asc
    [vars res]
    (if (coll? vars)
      (sort-by (fn [r] (reduce #(conj % (r %2)) [] vars)) res)
      (sort-by (fn [r] (get r vars)) res)))

  (defn order-desc
    [vars res]
    (if (coll? vars)
      (sort-by
       (fn [r] (reduce #(conj % (r %2)) [] vars))
       #(- (compare % %2))
       res)
      (sort-by #(get % vars) #(- (compare % %2)) res)))

  (defn distinct-result-set
    [res]
    (->> res
         (reduce
          (fn [acc r]
            (let [vs (set (vals r))]
              (if (acc vs) acc (assoc acc vs r))))
          {})
         (vals)))

  (defn keywordize-result-vars
    [res]
    (map
     (fn [r] (into {} (map (fn [[k v]] [(-> k qvar-name keyword) v]) r)))
     res))

  (defn compile-filter-fn
    [filters]
    (fn [res] (every? (fn [[k f]] (if-let [rv (res k)] (f rv) true)) filters)))

  (defn compile-bind-fn
    [bindings]
    (fn [res]
      (reduce-kv
       (fn [acc k f]
         (if-let [rv (f res (res k))]
           (assoc acc k rv)
           acc))
       res bindings)))
#+END_SRC

*** Graphviz export
**** TODO move to separate ns

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn triples->dot
    "Takes a seq of triples and returns them as digraph spec in
    Graphviz .dot format."
    [triples]
    (apply
     str
     (concat
      "digraph G {\n"
      "node[color=\"black\",style=\"filled\",fontname=\"Inconsolata\",fontcolor=\"white\"];\n"
      "edge[fontname=\"Inconsolata\",fontsize=\"9\"];\n"
      (map
       (fn [t]
         (let [[s p o] (map #(if (string? %) % (pr-str %)) t)]
           (str "\"" s "\" -> \"" o "\" [label=\"" p "\"];\n")))
       triples)
      "}")))
#+END_SRC

** Joins

#+BEGIN_SRC clojure :noweb-ref joins
  (defn join
    [a b]
    (->> (set/join a b)
         (mapcat
          (fn [k]
            (if (unique-bindings? k)
              [k])))))

  (defn join-optional
    [a b]
    (loop [old (transient #{}), new (transient #{}), kb b]
      (if kb
        (let [kb' [(first kb)]
              [old new] (loop [old old, new new, ka a]
                          (if ka
                            (let [ka' (first ka)
                                  j (first (set/join [ka'] kb'))]
                              (if j
                                (recur (conj! old ka') (conj! new j) (next ka))
                                (recur old new (next ka))))
                            [old new]))]
          (recur old new (next kb)))
        (let [new (persistent! new)]
          (if (seq new)
            (into (apply disj (set a) (persistent! old)) new)
            a)))))

   (defn minus
     [a b]
     (let [vars (accumulate-result-vars b)]
       (reduce-kv
        (fn [res k v]
          (let [v (if (coll? v) v [v])]
            (reduce
             (fn [res v] (vec (remove (fn [r] (= (r k) v)) res))) res v)))
        a vars)))

   (defn union
     [a b] (set (concat a b)))
#+END_SRC

** Select

#+BEGIN_SRC clojure :noweb-ref selectors
  (defn unbound-var?
    [bindings v? x] (and v? (not (bindings x))))

  (defn bind-translator
    [vs? vp? vo? [s p o]]
    (if vs?
      (if vp?
        (if vo?
          (fn [[s' p' o']] {s s' p p' o o'})
          (fn [[s' p']] {s s' p p'}))
        (if vo?
          (fn [[s' _ o']] {s s' o o'})
          (fn [r] {s (first r)})))
      (if vp?
        (if vo?
          (fn [[_ p' o']] {p p' o o'})
          (fn [r] {p (r 1)}))
        (if vo?
          (fn [r] {o (r 2)})
          (fn [_] {})))))

  (defn unbound-vars-translator
    [bindings vs? vp? vo? [s p o]]
    (if (unbound-var? bindings vs? s)
      (if (unbound-var? bindings vp? p)
        (if (unbound-var? bindings vo? o)
          (fn [p] [nil nil nil])
          (fn [p] [nil nil (p 2)]))
        (if (unbound-var? bindings vo? o)
          (fn [p] [nil (p 1) nil])
          (fn [p] (assoc p 0 nil))))
      (if (unbound-var? bindings vp? p)
        (if (unbound-var? bindings vo? o)
          (fn [p] [(p 0) nil nil])
          (fn [p] (assoc p 1 nil)))
        (if (unbound-var? bindings vo? o)
          (fn [p] (assoc p 2 nil))
          identity))))

  (defn select-with-bindings
    [ds bindings opts [s p o :as t]]
    (let [patterns (produce-patterns-with-bound-vars t bindings)
          _ (prn :patterns patterns)
          vs? (qvar? s), vp? (qvar? p), vo? (qvar? o)
          vmap (bind-translator vs? vp? vo? t)
          pmap (unbound-vars-translator bindings vs? vp? vo? t)
          verify (triple-verifier t vs? vp? vo?)
          flt (opts :filter)
          res-fn (if flt
                   (let [flt (if (map? flt) (compile-filter-fn flt) flt)]
                     #(if (verify %)
                        (let [vbinds (vmap %)]
                          (if (flt vbinds) vbinds))))
                   #(if (verify %) (vmap %)))]
      (loop [acc (transient []), ps patterns]
        (if ps
          (let [[qs qp qo] (pmap (vec (first ps)))
                _ (prn :select qs qp qo)
                res (api/select ds qs qp qo)]
            (if (seq res)
              (recur
               (loop [acc acc, res res]
                 (if res
                   (let [r (res-fn (first res))]
                     (if r
                       (recur (conj! acc r) (next res))
                       (recur acc (next res))))
                   acc))
               (next ps))
              (recur acc (next ps))))
          (persistent! acc)))))

  (defn select-join
    ([ds patterns]
       (select-join ds {} {} patterns))
    ([ds bindings {bind :bind flt :filter opt? :optional?} patterns]
       (let [[p & ps] (sort-patterns patterns)
             res      (select-with-bindings ds bindings {} p)
             join-fn  (if opt? join-optional join)
             flt      (if (map? flt)  (compile-filter-fn flt) flt)
             bind     (if (map? bind) (compile-bind-fn bind) bind)]
         (if (seq res)
           (loop [res res, ps ps]
             (if ps
               (let [binds (merge-with into (accumulate-result-vars res) bindings)
                     r' (select-with-bindings ds binds {} (first ps))
                     res (if (seq r') (join-fn res r'))]
                 (if (seq res)
                   (recur res (next ps))))
               (cond->> res
                        flt (filter flt)
                        bind (map bind))))))))
#+END_SRC

** Transitive properties & path queries

If using equal min/max search depth, resort to =select-join= with
expanded pattern. In that case the predicate can be a seq =[pred1
pred2 ..]= which is expanded cyclically for =depth= hops, e.g:

 : (select-transitive ds '[?s [mother father] ?o] 3 3)

Else the fn takes a standard pattern with the subject or object either a given
constant or qvar:

Select all 'mother' rels from 1 - 3 hops (i.e. from mother -> great-grandmother)
 : (select-transitive ds '[?s mother ?c] 1 3)

If the object is not a qvar, the search is executed in reverse direction:
 : (select-transitive ds '[?m mother 'toxi])

Select only grandchildren for given person:
 : (select-transitive ds '[john father ?c] 2 2)
 : ;; same as...
 : (select-join ds '[[john father ?p] [?p father ?c]])

*** TODO Specifying variable length paths

- http://www.w3.org/TR/sparql11-query/#propertypaths

#+BEGIN_SRC clojure :noweb-ref dfs
  (defn subvec-slices
    "Takes a min & max count and returns function accepting a vector as
    single arg. When called, returns vector of subvec slices each starting
    at index 0 and with an increasing length from min to max."
    [n1 n2]
    (fn [path]
      (mapv #(subvec path 0 %) (range n1 (inc (min (count path) n2))))))

  (defn dfs-forward*
    [ds s p sv acc min max]
    (if (<= (count acc) max)
      (let [acc (conj acc sv)
            o (auto-qvar)
            r (select-with-bindings ds {s sv} {} [s p o])]
        (if (seq r)
          (let [visited (set acc)
                ovals (filter (comp not visited) (set (map o r)))]
            (if (seq ovals)
              (#+clj r/mapcat #+cljs mapcat
                     (fn [ov] (dfs-forward* ds o p ov acc min max))
                     ovals)
              [acc]))
          (if (> (count acc) min) [acc])))
      [acc]))

  (defn dfs-backward*
    [ds o p ov acc min max]
    (if (<= (count acc) max)
      (let [acc (conj acc ov)
            s (auto-qvar)
            r (select-with-bindings ds {o ov} {} [s p o])]
        (if (seq r)
          (let [visited (set acc)
                svals (filter (comp not visited) (set (map s r)))]
            (if (seq svals)
              (#+clj r/mapcat #+cljs mapcat
                     (fn [sv] (dfs-backward* ds s p sv acc min max))
                     svals)
              [acc]))
          (if (> (count acc) min) [acc])))
      [acc]))

  (defn select-transitive
    ([ds [s p o :as t]]
       (if (vector? p)
         (select-transitive ds t (count p) (count p))
         (select-transitive ds t 1 1000000)))
    ([ds [s p o] mind maxd]
       (let [mind (max mind 1)
             maxd (max maxd 1)]
         (if (= mind maxd)
           (let [p (if (vector? p) p [p])
                 p (take mind (cycle p))]
             (select-join ds {} {} (resolve-path-pattern [s p o])))
           (let [vs? (qvar? s)
                 vo? (qvar? o)
                 v (auto-qvar)
                 conf (cond
                       (and vs? vo?) {:s s ;; [?s p ?o]
                                      :o v
                                      :bmap {}
                                      :lookup (fn [b] [(b v) (b s)])
                                      :bind (fn [p] {s (first p) o (peek p)})
                                      :search dfs-forward*}
                       vo?           {:s v ;; [x p ?o]
                                      :o o
                                      :bmap {v s}
                                      :lookup (fn [b] [(b o) (b v)])
                                      :bind (fn [p] {o (peek p)})
                                      :search dfs-forward*}
                       vs?           {:s s ;; [?s p x]
                                      :o v
                                      :bmap {v o}
                                      :lookup (fn [b] [(b s) (b v)])
                                      :bind (fn [p] {s (peek p)})
                                      :search dfs-backward*})
                 {:keys [bind search]} conf
                 slices (subvec-slices (inc mind) (inc maxd))]
             (->> (select-with-bindings ds (:bmap conf) {} [(:s conf) p (:o conf)])
                  (r/map    (:lookup conf))
                  (r/mapcat #(search ds v p (% 0) [(% 1)] mind maxd))
                  (r/mapcat slices)
                  (r/map    bind)
                  (into #{})))))))
#+END_SRC

** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/query.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.query
    (:require
     [thi.ng.trio.core :as api]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.data.unionfind :as uf]
     [clojure.set :as set]
     [clojure.core.reducers :as r]))

  <<helpers>>

  <<joins>>

  <<selectors>>

  <<dfs>>

  <<processor>>
#+END_SRC
