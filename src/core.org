#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.core

This namespace provides various protocols for the low-level triple
store API, as well as a persistent in-memory store implementation and
a flexible dataset type to aggregate models/stores and query multiple
at once.

** Protocol definitions

*** PModel
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PModel
    (select [_] [_ s p o] [_ g s p o])
    (subjects [_])
    (predicates [_])
    (objects [_])
    (subject? [_ x])
    (predicate? [_ x])
    (object? [_ x])
    (indexed? [_ x])
    (model-size [_]))
#+END_SRC

*** PDataset
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PDataset
    (remove-model [_ id])
    (update-model [_ id f])
    (get-model [_ id]))
#+END_SRC

*** PStatementAccess
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PStatementAccess
    (add-statement [_ s] [_ g s])
    (add-bulk [_ statements] [_ g statements])
    (remove-statement [_ s] [_ g s])
    (remove-bulk [_ statements] [_ g statements])
    (update-statement [_ s s'] [_ g s s'])
    (remove-subject [_ s] [_ g s]))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn remove-from-index
    [idx i1 i2 i3]
    (let [kv (idx i1)
          v (disj (kv i2) i3)
          kv (if (seq v) kv (dissoc kv i2))]
      (if (seq kv)
        (if (seq v)
          (assoc-in idx [i1 i2] v)
          (assoc idx i1 kv))
        (dissoc idx i1))))

  (defn select-seq
    [coll statement-fn & [flt]]
    (mapcat
     (fn [inner]
       (map
        (statement-fn (inner 0))
        (if flt
          (filter flt (inner 1))
          (inner 1))))
     coll))
#+END_SRC

** Triple datatype
*** Protocol helpers
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj
  (defn map-entry
    [k v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry
      (key [_] k)
      (getKey [_] k)
      (val [_] v)
      (getValue [_] v)
      (hashCode [_]
        (-> 31
            (unchecked-add-int (hash k))
            (unchecked-multiply-int 31)
            (unchecked-add-int (hash v))))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals
              k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals
              v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC

*** Templates

In order to deduplicate shared code between both the Clojure &
ClojureScript protocol implementations, we first define a few snippets
as re-usable templates, which are injected in the appropriate places
of the code.

**** apply
#+NAME: tpl-apply
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string "{{fn}}" fn
  "(condp = (count args)
    1 ({{fn}} _ (first args) nil)
    2 ({{fn}} _ (first args) (second args))
    (err/arity-error! (count args)))")
#+END_SRC
**** assocN
#+BEGIN_SRC clojure :noweb-ref tpl-assoc-n
  (case (int k)
    0 (Triple. v p o nil)
    1 (Triple. s v o nil)
    2 (Triple. s p v nil)
    (err/key-error! k))
#+END_SRC
**** containsKey
#+BEGIN_SRC clojure :noweb-ref tpl-contains-key
  (not (nil? (#{0 1 2 :s :p :o} k)))
#+END_SRC
**** equals / equiv
#+NAME: tpl-equals
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string
   "{{fn}}" fn
   "(if (instance? Triple x)
      (and ({{fn}} s (.-s ^Triple x))
           ({{fn}} p (.-p ^Triple x))
           ({{fn}} o (.-o ^Triple x)))
      (and (instance? java.util.Collection x)
           (= 3 (count x))
           ({{fn}} s (nth x 0))
           ({{fn}} p (nth x 1))
           ({{fn}} o (nth x 2))))")
#+END_SRC
**** nth w/ error
#+BEGIN_SRC clojure :noweb-ref tpl-nth-err
  (case (int k) 0 s, 1 p, 2 o, (err/key-error! k))
#+END_SRC
**** nth w/ notfound
#+BEGIN_SRC clojure :noweb-ref tpl-nth-nf
  (case (int k) 0 s, 1 p, 2 o, nf)
#+END_SRC
**** compare
#+BEGIN_SRC clojure :noweb-ref tpl-compare
  (if (instance? Triple x)
    (let [c (compare s (.-s ^Triple x))]
      (if (== 0 c)
        (let [c (compare p (.-p ^Triple x))]
          (if (== 0 c)
            (compare o (.-o ^Triple x))
            c))
        c))
    (let [c (count x)]
      (if (== 3 c) (compare x _) (- 3 c))))
#+END_SRC
**** hashCode
#+BEGIN_SRC clojure :noweb-ref tpl-hashcode
  (-> 31
      (unchecked-add-int (hash s))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash p))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash o)))
#+END_SRC
**** rest
#+BEGIN_SRC clojure :noweb-ref tpl-rest
  (cons p (cons o nil))
#+END_SRC
**** rseq
#+BEGIN_SRC clojure :noweb-ref tpl-rseq
  (Triple. o p s nil)
#+END_SRC
**** reduce
#+BEGIN_SRC clojure :noweb-ref tpl-reduce
  (let [acc (f s p)]
    (if (reduced? acc)
      @acc
      (f acc o)))
#+END_SRC

**** reduce w/ init
#+BEGIN_SRC clojure :noweb-ref tpl-reduce-start
  (let [acc (f start s)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc p)]
        (if (reduced? acc)
          @acc
          (f acc o)))))
#+END_SRC

*** Implementation
#+BEGIN_SRC clojure :noweb-ref triple
  (deftype Triple
    #+clj  [s p o ^:volatile-mutable __hash]
    #+cljs [s p o ^:mutable __hash]
#+END_SRC
**** Clojure
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle _ k nf))

  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
          [_] (.invoke ^clojure.lang.IFn _))

  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle _ k nf))
  ,#+clj (applyTo
         [_ args]
         <<tpl-apply(fn="swizzle")>>)

  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] <<tpl-contains-key>>)
  ,#+clj (entryAt
         [_ k] (map-entry k <<tpl-nth-err>>))
  ,#+clj (assoc
            [_ k v] (swizzle-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         <<tpl-assoc-n>>)

  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list s p o)))
  ,#+clj (toArray
         [_] (object-array _))
  ,#+clj (size
         [_] 3)

  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] s)
  ,#+clj (next
         [_] <<tpl-rest>>)
  ,#+clj (more
         [_] <<tpl-rest>>)
  ,#+clj (cons
         [_ x] [s p o x])
  ,#+clj (peek
         [_] o)
  ,#+clj (pop
         [_] [s p])
  ,#+clj (rseq
         [_] <<tpl-rseq>>)
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ k] <<tpl-nth-err>>)
  ,#+clj (nth
         [_ k nf] <<tpl-nth-nf>>)
  ,#+clj (equiv
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equiv")>>)
  ,#+clj (equals
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equals")>>)
  ,#+clj (hashCode
         [_]
         <<tpl-hashcode>>)

  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         (or __hash (set! __hash
                          (mix-collection-hash
                           <<tpl-hashcode>>
                           3))))

  ,#+clj Comparable
  ,#+clj (compareTo
         [_ x]
         <<tpl-compare>>)

  ,#+clj cp/InternalReduce
  ,#+clj (internal-reduce
         [_ f start]
         <<tpl-reduce-start>>)

  ,#+clj cp/CollReduce
  ,#+clj (coll-reduce
         [_ f]
         <<tpl-reduce>>)
  ,#+clj (coll-reduce
         [_ f start]
         <<tpl-reduce-start>>)

  ,#+clj Object
  ,#+clj (toString
         [_]
         (.toString
          (doto (StringBuilder. "[")
            (.append (pr-str s))
            (.append " ")
            (.append (pr-str p))
            (.append " ")
            (.append (pr-str o))
            (.append "]"))))
#+END_SRC
**** ClojureScript protocols
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Triple. s p o __hash))

  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle _ k nf))

  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle _ k nf))

  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)

  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] <<tpl-contains-key>>)
  ,#+cljs (-assoc
          [_ k v] (swizzle-assoc _ k v))

  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          <<tpl-assoc-n>>)

  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] s)
  ,#+cljs (-rest
          [_] <<tpl-rest>>)

  ,#+cljs INext
  ,#+cljs (-next
          [_] <<tpl-rest>>)

  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)

  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] <<tpl-rseq>>)

  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ k] <<tpl-nth-err>>)
  ,#+cljs (-nth
          [_ k nf] <<tpl-nth-nf>>)

  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ x] [s p o x])

  ,#+cljs IStack
  ,#+cljs (-peek
          [_] o)
  ,#+cljs (-pop
          [_] [s p])

  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ x]
          <<tpl-compare>>)

  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (or __hash (set! (.-__hash _) (hash-coll _))))

  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ x]
          (if (instance? Triple x)
            (and (= s (.-s ^Triple x)) (= p (.-p ^Triple x)) (= o (.-o ^Triple x)))
            (and (sequential? x) (= 3 (count x))
                 (= s (nth x 0)) (= p (nth x 1)) (= o (nth x 2)))))

  ,#+cljs IReduce
  ,#+cljs (-reduce
          [coll f]
          <<tpl-reduce>>)
  ,#+cljs (-reduce
          [coll f start]
          <<tpl-reduce-start>>)

  ,#+cljs Object
  ,#+cljs (toString
          [_] (str "[" s " " p " " o "]"))
#+END_SRC

**** End of triple type
#+BEGIN_SRC clojure :noweb-ref triple
  )
#+END_SRC

*** Override print methods
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj (require 'clojure.pprint)
  ,#+clj (prefer-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector clojure.lang.ISeq)
  ,#+clj (defmethod print-method Triple [^Triple o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC

*** Swizzling
#+BEGIN_SRC clojure triple :noweb-ref triple
  (defn- lookup3
    [^Triple _ k nf]
    (case k
      \s (.-s _)
      \p (.-p _)
      \o (.-o _)
      (or nf (err/key-error! k))))

  (defn- swizzle
    [^Triple _ k default]
    (if (number? k)
      (case (int k)
        0 (.-s _)
        1 (.-p _)
        2 (.-o _)
        (or default (err/key-error! k)))
      (case k
        :s (.-s _)
        :p (.-p _)
        :o (.-o _)
        (let [n (name k) c (count n)]
          (case c
            2 [(lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)]
            3 (Triple.
               (lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)
               (lookup3 _ (nth n 2) default)
               nil)
            (or default (err/key-error! k)))))))

  (defn- swizzle-assoc*
    [_ keymap k v]
    (let [n (name k)
          c (count n)]
      (if (and (<= c (count keymap)) (== c (count v) (count (into #{} n))))
        (loop [acc (object-array 3), i 0, n n]
          (if n
            (recur (do (aset acc (keymap (first n)) (v i)) acc) (inc i) (next n))
            (Triple. (aget acc 0) (aget acc 1) (aget acc 2) nil)))
        (err/key-error! k))))

  (defn- swizzle-assoc
    [^Triple _ k v]
    (case k
      :s (Triple. v (.-p _) (.-o _) nil)
      :p (Triple. (.-s _) v (.-o _) nil)
      :o (Triple. (.-s _) (.-p _) v nil)
      0 (Triple. v (.-p _) (.-o _) nil)
      1 (Triple. (.-s _) v (.-o _) nil)
      2 (Triple. (.-s _) (.-p _) v nil)
      (swizzle-assoc* _ {\s 0 \p 1 \o 2} k v)))
#+END_SRC
*** Constructor
#+BEGIN_SRC clojure :noweb-ref triple
  (defn triple
    ([s p o] (Triple. s p o nil))
    ([t] (if (instance? Triple t) t (let [[s p o] t] (Triple. s p o nil)))))
#+END_SRC

** In-memory stores

*** Classic 3-index implementation
#+BEGIN_SRC clojure :noweb-ref memstore
  (defrecord PlainMemoryStore [spo pos osp size]
    PStatementAccess
    (add-statement
      [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil))
        _
        (let [s (get (find spo s) 0 s)
              p (get (find pos p) 0 p)
              o (get (find osp o) 0 o)
              t (Triple. s p o nil)]
          (PlainMemoryStore.
           (update-in spo [s p] d/set-conj t)
           (update-in pos [p o] d/set-conj t)
           (update-in osp [o s] d/set-conj t)
           (inc size)))))
    (add-bulk [_ statements]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs statements]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur changed? spo pos osp size (next xs))
              (let [s (get (find spo s) 0 s)
                    p (get (find pos p) 0 p)
                    o (get (find osp o) 0 o)
                    t (Triple. s p o nil)]
                (recur
                 true
                 (update-in spo [s p] d/set-conj t)
                 (update-in pos [p o] d/set-conj t)
                 (update-in osp [o s] d/set-conj t)
                 (inc size)
                 (next xs)))))
          (if changed?
            (PlainMemoryStore. spo pos osp size)
            _))))
    (remove-statement [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil))
        (PlainMemoryStore.
         (remove-from-index spo s p t)
         (remove-from-index pos p o t)
         (remove-from-index osp o s t)
         (dec size))
        _))
    (remove-bulk [_ statements]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs statements]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur
               true
               (remove-from-index spo s p t)
               (remove-from-index pos p o t)
               (remove-from-index osp o s t)
               (dec size)
               (next xs))
              (recur changed? spo pos osp size (next xs))))
          (if changed?
            (PlainMemoryStore. spo pos osp size)
            _))))
    (update-statement [_ s1 s2]
      (add-statement (remove-statement _ s1) s2))
    (remove-subject [_ s]
      (remove-bulk _ (select _ s nil nil)))

    PModel
    (subject? [_ x]
      (if (spo x) x))
    (predicate? [_ x]
      (if (pos x) x))
    (object? [_ x]
      (if (osp x) x))
    (indexed? [_ x]
      (if (or (spo x) (pos x) (osp x)) x))
    (subjects [_] (keys spo))
    (predicates [_] (keys pos))
    (objects [_] (keys osp))
    (model-size [_] size)
    (select [_]
      (select _ nil nil nil))
    (select
      [_ s p o]
      ;;(prn :spo s p o)
      (if s
        (if p
          (if o
            ;; s p o
            (let [t (triple s p o)]
              (if (-> spo (get s nil) (get p nil) (get t nil)) [t]))
            ;; s p nil
            (-> spo (get s nil) (get p nil)))
          ;; s nil o / s nil nil
          (if o
            (-> osp (get o nil) (get s nil))
            (->> (spo s) vals (apply concat))))
        (if p
          (if o
            ;; nil p o
            (-> pos (get p nil) (get o nil))
            ;; nil p nil
            (->> (pos p) vals (apply concat)))
          (if o
            ;; nil nil o
            (->> (osp o) vals (apply concat))
            ;; nil nil nil
            (->> spo vals (mapcat vals) (apply concat)))))))
#+END_SRC

*** Triple graph (WIP)

Currently highly inefficient (4-5x slower than =PlainMemoryStore=),
but still thinking this approach of treating triples (incl. with
wildcards) as graph, might have better milage later when solving query
joins...

#+BEGIN_SRC clojure :noweb-ref memstore
  (defprotocol PNode
    (get-children [_])
    (add-child [_ c])
    (remove-child [_ c]))

  (defprotocol PGraph
    (add-node [_ n] [_ n parents])
    (get-node [_ t])
    (get-ids [_])
    (get-nodes [_]))

  (deftype TripleNode [triple ^:volatile-mutable children]
    PNode
    (get-children [_] children)
    (add-child [_ c] (set! children (conj (or children #{}) c)) _)
    (remove-child [_ c] (set! children (disj children c)) _)

    Object
    (toString [_] (str (pr-str triple) " " (pr-str children))))

  (declare select-tg*)

  (deftype TripleGraph [nodes ids next-id]
    Object
    (toString
      [_] (str ":nodes " (pr-str nodes)
               " :ids " (pr-str ids)
               " :next " next-id))

    PGraph
    (add-node
      [_ n] (add-node _ n nil))
    (add-node
      [_ n parents]
      (let [g (TripleGraph.
               (assoc nodes next-id n)
               (assoc ids (.-triple  ^TripleNode n) next-id)
               (inc next-id))]
        (when (seq parents)
          (doseq [^TripleNode p parents]
            (add-child p next-id)))
        g))
    (get-node
      [_ t] (nodes (ids t)))

    PStatementAccess
    (add-statement
      [_ [s p o :as t]]
      (if-not (ids t)
        (let [id (.-next-id _)
              ^TripleGraph g (add-node _ (TripleNode. t nil) nil)
              index-branch (fn [g patterns]
                             (loop [^TripleGraph g g, id id, ps patterns]
                               (if ps
                                 (let [id' ((.-ids g) (first ps))]
                                   (if id'
                                     (do
                                       (add-child ^TripleNode ((.-nodes g) id') id)
                                       g)
                                     (recur
                                      (add-node g (TripleNode. (first ps) #{id}) nil)
                                      (.-next-id g)
                                      (next ps))))
                                 g)))]
          (-> (index-branch g [[s p nil] [s nil nil] [nil nil nil]])
              (index-branch [[nil p o] [nil p nil]])
              (index-branch [[s nil o] [nil nil o]])
              ))
        _))

    PModel
    (select
      [_ s p o]
      (persistent! (select-tg* nodes (ids [s p o]) (transient [])))))

  (defn- select-tg*
    [nodes id acc]
    (let [^TripleNode n (nodes id)]
      (if n
        (let [c (get-children n)]
          (if c
            (reduce #(select-tg* nodes %2 %) acc c)
            (conj! acc (.-triple n))))
        acc)))

  (defn triple-graph
    []
    (let [root (TripleNode. [nil nil nil] nil)]
      (add-node (TripleGraph. {} {} 0) root)))
#+END_SRC
**** Old add-statement
#+BEGIN_SRC clojure
  (add-statement
   [_ [s p o :as t]]
   (let [[_ t1s] (if-let [n (nodes (ids [s nil nil]))]
                   [_ n] (let [n (index-node [s nil nil])] [(add-node _ n [(nodes 0)]) n]))
         [_ t1p] (if-let [n (nodes (ids [nil p nil]))]
                   [_ n] (let [n (index-node [nil p nil])] [(add-node _ n) n]))
         [_ t1o] (if-let [n (nodes (ids [nil nil o]))]
                   [_ n] (let [n (index-node [nil nil o])] [(add-node _ n) n]))
         [_ t2sp] (if-let [n (nodes (ids [s p nil]))]
                    [_ n] (let [n (index-node [s p nil])] [(add-node _ n [t1s]) n]))
         [_ t2po] (if-let [n (nodes (ids [nil p o]))]
                    [_ n] (let [n (index-node [nil p o])] [(add-node _ n [t1p]) n]))
         [_ t2so] (if-let [n (nodes (ids [s nil o]))]
                    [_ n] (let [n (index-node [s nil o])] [(add-node _ n [t1o]) n]))]
     (add-node _ (index-node t) [t2sp t2so t2po])))
#+END_SRC
*** Constructors
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-store
    [& triples]
    (add-bulk (PlainMemoryStore. (hash-map) (hash-map) (hash-map) 0) triples))
#+END_SRC

** Multi-store dataset

*** Type implementation
#+BEGIN_SRC clojure :noweb-ref dataset
  (defrecord PlainDataset [models]
    PStatementAccess
    (add-statement [_ s]
      (add-statement _ :default s))
    (add-statement [_ g s]
      (update-in _ [:models g] add-statement s))
    (add-bulk [_ statements]
      (add-bulk _ :default statements))
    (add-bulk [_ g statements]
      (update-in _ [:models g] add-bulk statements))
    (remove-statement [_ s]
      (remove-statement _ :default s))
    (remove-statement [_ g s]
      (update-in _ [:models g] remove-statement s))
    (remove-bulk [_ statements]
      (remove-bulk _ :default statements))
    (remove-bulk [_ g statements]
      (update-in _ [:models g] remove-bulk statements))
    (remove-subject [_ s]
      (remove-subject _ :default s))
    (remove-subject [_ g s]
      (update-in _ [:models g] remove-subject s))

    PModel
    (select [_]
      (select _ nil nil nil))
    (select [_ s p o]
      (mapcat #(select % s p o) (vals models)))
    (select [_ g s p o]
      (if-let [g (models g)] (select g s p o)))
    (subject? [_ x]
      (some #(subject? % x) (vals models)))
    (predicate? [_ x]
      (some #(predicate? % x) (vals models)))
    (object? [_ x]
      (some #(object? % x) (vals models)))
    (indexed? [_ x]
      (some #(indexed? % x) (vals models)))
    (subjects [_]
      (set (mapcat subjects (vals models))))
    (predicates [_]
      (set (mapcat predicates (vals models))))
    (objects [_]
      (set (mapcat objects (vals models))))
    (model-size [_]
      (reduce + (map model-size (vals models))))

    PDataset
    (update-model [_ id m]
      (assoc-in _ [:models id] m))
    (remove-model [_ id]
      (update-in _ [:models] dissoc id))
    (get-model [_ id]
      (models id)))
#+END_SRC

*** Constructor
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-dataset
    [& {:as models}]
    (PlainDataset. (assoc models :default (plain-store))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.core
    (:refer-clojure :exclude [object? indexed?])
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [clojure.core.protocols :as cp]))

  <<protos>>

  <<helpers>>

  (declare swizzle swizzle-assoc)

  <<triple>>

  <<memstore>>

  <<dataset>>

  <<ctors>>
#+END_SRC
