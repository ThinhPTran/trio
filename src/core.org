#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.core

This namespace provides various protocols for the low-level triple
store API, as well as a persistent in-memory store implementation and
a flexible dataset type to aggregate models/stores and query multiple
at once.

** Protocol definitions

*** PModelConvert

This protocol is used to easily convert Clojure collections into an
triplestore and so allow the query engine to operate directly on these
collections. Implementations are provided for sequences & maps further
below.

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PModelConvert
   (as-model [_]))
#+END_SRC

*** PModel

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PModel
    (select [_] [_ s p o] [_ g s p o])
    (subjects [_])
    (predicates [_])
    (objects [_])
    (subject? [_ x])
    (predicate? [_ x])
    (object? [_ x])
    (indexed? [_ x])
    (model-size [_]))
#+END_SRC

*** PDataset

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PDataset
    (remove-model [_ id])
    (update-model [_ id f])
    (get-model [_ id]))
#+END_SRC

*** PStatementAccess

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PStatementAccess
    (add-statement [_ s] [_ g s])
    (add-bulk [_ statements] [_ g statements])
    (remove-statement [_ s] [_ g s])
    (remove-bulk [_ statements] [_ g statements])
    (update-statement [_ s s'] [_ g s s'])
    (remove-subject [_ s] [_ g s]))
#+END_SRC

*** PAliasModelSupport

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PAliasModelSupport
    (rewrite-alias [_ a b]))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn- remove-from-index
    [idx i1 i2 i3]
    (let [kv (idx i1)
          v (disj (kv i2) i3)
          kv (if (seq v) kv (dissoc kv i2))]
      (if (seq kv)
        (if (seq v)
          (assoc-in idx [i1 i2] v)
          (assoc idx i1 kv))
        (dissoc idx i1))))

  (defn- rewrite-alias*
    [store pred id p q]
    (if (pred store p)
      (let [xs (apply select store (assoc [nil nil nil] id p))
            store (remove-bulk store xs)]
        (add-bulk store (map #(assoc % id q) xs)))
      store))

  (defn rewrite-alias-naive
    [store p q]
    (-> store
        (rewrite-alias* subject?   0 p q)
        (rewrite-alias* predicate? 1 p q)
        (rewrite-alias* object?    2 p q)))

  (defn trace [prefix x] (prn prefix x) x)
#+END_SRC

** Triple datatype
*** Templates

In order to deduplicate shared code between both the Clojure &
ClojureScript protocol implementations, we first define a few snippets
as re-usable templates, which are injected in the appropriate places
of the code.

**** apply
#+NAME: tpl-apply
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string "{{fn}}" fn
  "(condp = (count args)
    1 ({{fn}} _ (first args) nil)
    2 ({{fn}} _ (first args) (second args))
    (err/arity-error! (count args)))")
#+END_SRC
**** assocN
#+BEGIN_SRC clojure :noweb-ref tpl-assoc-n
  (case (int k)
    0 (Triple. v p o nil)
    1 (Triple. s v o nil)
    2 (Triple. s p v nil)
    (err/key-error! k))
#+END_SRC
**** containsKey
#+BEGIN_SRC clojure :noweb-ref tpl-contains-key
  (not (nil? (#{0 1 2 :s :p :o} k)))
#+END_SRC
**** equals / equiv
#+NAME: tpl-equals
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string
   "{{fn}}" fn
   "(if (instance? Triple x)
      (and ({{fn}} s (.-s ^Triple x))
           ({{fn}} p (.-p ^Triple x))
           ({{fn}} o (.-o ^Triple x)))
      (and (instance? java.util.Collection x)
           (= 3 (count x))
           ({{fn}} s (nth x 0))
           ({{fn}} p (nth x 1))
           ({{fn}} o (nth x 2))))")
#+END_SRC
**** nth w/ error
#+BEGIN_SRC clojure :noweb-ref tpl-nth-err
  (case (int k) 0 s, 1 p, 2 o, (err/key-error! k))
#+END_SRC
**** nth w/ notfound
#+BEGIN_SRC clojure :noweb-ref tpl-nth-nf
  (case (int k) 0 s, 1 p, 2 o, nf)
#+END_SRC
**** compare
#+BEGIN_SRC clojure :noweb-ref tpl-compare
  (if (instance? Triple x)
    (let [c (compare s (.-s ^Triple x))]
      (if (== 0 c)
        (let [c (compare p (.-p ^Triple x))]
          (if (== 0 c)
            (compare o (.-o ^Triple x))
            c))
        c))
    (let [c (count x)]
      (if (== 3 c) (compare x _) (- 3 c))))
#+END_SRC
**** hashCode
#+BEGIN_SRC clojure :noweb-ref tpl-hashcode
  (-> 31
      (unchecked-add-int (hash s))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash p))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash o)))
#+END_SRC
**** rest
#+BEGIN_SRC clojure :noweb-ref tpl-rest
  (cons p (cons o nil))
#+END_SRC
**** rseq
#+BEGIN_SRC clojure :noweb-ref tpl-rseq
  (Triple. o p s nil)
#+END_SRC
**** reduce
#+BEGIN_SRC clojure :noweb-ref tpl-reduce
  (let [acc (f s p)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc o)]
        (if (reduced? acc)
          @acc
          acc))))
#+END_SRC
**** reduce w/ init
#+BEGIN_SRC clojure :noweb-ref tpl-reduce-start
  (let [acc (f start s)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc p)]
        (if (reduced? acc)
          @acc
          (let [acc (f acc o)]
            (if (reduced? acc)
              @acc
              acc))))))
#+END_SRC

*** Implementation
#+BEGIN_SRC clojure :noweb-ref triple
  (deftype Triple
    #+clj  [s p o ^:unsynchronized-mutable __hash]
    #+cljs [s p o ^:mutable __hash]
#+END_SRC
**** Clojure
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle _ k nf))

  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
          [_] (.invoke ^clojure.lang.IFn _))

  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle _ k nf))
  ,#+clj (applyTo
         [_ args]
         <<tpl-apply(fn="swizzle")>>)

  ,#+clj clojure.lang.IPersistentVector
  ,#+clj clojure.lang.Associative
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] <<tpl-contains-key>>)
  ,#+clj (entryAt
         [_ k] (clojure.lang.MapEntry. k <<tpl-nth-err>>))
  ,#+clj (assoc
            [_ k v] (swizzle-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         <<tpl-assoc-n>>)

  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list s p o)))
  ,#+clj (toArray
         [_] (object-array _))
  ,#+clj (size
         [_] 3)

  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] s)
  ,#+clj (next
         [_] <<tpl-rest>>)
  ,#+clj (more
         [_] <<tpl-rest>>)
  ,#+clj (cons
         [_ x] [s p o x])
  ,#+clj (peek
         [_] o)
  ,#+clj (pop
         [_] [s p])
  ,#+clj (rseq
         [_] <<tpl-rseq>>)
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ k] <<tpl-nth-err>>)
  ,#+clj (nth
         [_ k nf] <<tpl-nth-nf>>)
  ,#+clj (equiv
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equiv")>>)
  ,#+clj (equals
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equals")>>)
  ,#+clj (hashCode
         [_]
         <<tpl-hashcode>>)

  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         (or __hash (set! __hash
                          (mix-collection-hash
                           <<tpl-hashcode>>
                           3))))

  ,#+clj Comparable
  ,#+clj (compareTo
         [_ x]
         <<tpl-compare>>)

  ,#+clj cp/InternalReduce
  ,#+clj (internal-reduce
         [_ f start]
         <<tpl-reduce-start>>)

  ,#+clj cp/CollReduce
  ,#+clj (coll-reduce
         [_ f]
         <<tpl-reduce>>)
  ,#+clj (coll-reduce
         [_ f start]
         <<tpl-reduce-start>>)

  ,#+clj Object
  ,#+clj (toString
         [_]
         (.toString
          (doto (StringBuilder. "[")
            (.append (pr-str s))
            (.append " ")
            (.append (pr-str p))
            (.append " ")
            (.append (pr-str o))
            (.append "]"))))
#+END_SRC
**** ClojureScript protocols
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Triple. s p o __hash))

  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle _ k nf))

  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle _ k nf))

  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)

  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] <<tpl-contains-key>>)
  ,#+cljs (-assoc
          [_ k v] (swizzle-assoc _ k v))

  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          <<tpl-assoc-n>>)

  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] s)
  ,#+cljs (-rest
          [_] <<tpl-rest>>)

  ,#+cljs INext
  ,#+cljs (-next
          [_] <<tpl-rest>>)

  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)

  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] <<tpl-rseq>>)

  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ k] <<tpl-nth-err>>)
  ,#+cljs (-nth
          [_ k nf] <<tpl-nth-nf>>)

  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ x] [s p o x])

  ,#+cljs IStack
  ,#+cljs (-peek
          [_] o)
  ,#+cljs (-pop
          [_] [s p])

  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ x]
          <<tpl-compare>>)

  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (or __hash (set! (.-__hash _) (hash-coll _))))

  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ x]
          (if (instance? Triple x)
            (and (= s (.-s ^Triple x)) (= p (.-p ^Triple x)) (= o (.-o ^Triple x)))
            (and (sequential? x) (= 3 (count x))
                 (= s (nth x 0)) (= p (nth x 1)) (= o (nth x 2)))))

  ,#+cljs IReduce
  ,#+cljs (-reduce
          [coll f]
          <<tpl-reduce>>)
  ,#+cljs (-reduce
          [coll f start]
          <<tpl-reduce-start>>)

  ,#+cljs Object
  ,#+cljs (toString
          [_] (str "[" s " " p " " o "]"))
#+END_SRC

**** End of triple type
#+BEGIN_SRC clojure :noweb-ref triple
  )
#+END_SRC

*** Override print methods
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj (defmethod clojure.pprint/simple-dispatch Triple
    [^Triple o] ((get-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector) o))
  ,#+clj (defmethod print-method Triple [^Triple o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC

*** Swizzling
#+BEGIN_SRC clojure triple :noweb-ref triple
  (defn- lookup3
    [^Triple _ k nf]
    (case k
      \s (.-s _)
      \p (.-p _)
      \o (.-o _)
      (or nf (err/key-error! k))))

  (defn- swizzle
    [^Triple _ k default]
    (if (number? k)
      (case (int k)
        0 (.-s _)
        1 (.-p _)
        2 (.-o _)
        (or default (err/key-error! k)))
      (case k
        :s (.-s _)
        :p (.-p _)
        :o (.-o _)
        (let [n (name k) c (count n)]
          (case c
            2 [(lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)]
            3 (Triple.
               (lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)
               (lookup3 _ (nth n 2) default)
               nil)
            (or default (err/key-error! k)))))))

  (defn- swizzle-assoc*
    [_ keymap k v]
    (let [n (name k)
          c (count n)]
      (if (and (<= c (count keymap)) (== c (count v) (count (into #{} n))))
        (loop [acc (object-array 3), i 0, n n]
          (if n
            (recur (do (aset acc (keymap (first n)) (v i)) acc) (inc i) (next n))
            (Triple. (aget acc 0) (aget acc 1) (aget acc 2) nil)))
        (err/key-error! k))))

  (defn- swizzle-assoc
    [^Triple _ k v]
    (case k
      :s (Triple. v (.-p _) (.-o _) nil)
      :p (Triple. (.-s _) v (.-o _) nil)
      :o (Triple. (.-s _) (.-p _) v nil)
      0 (Triple. v (.-p _) (.-o _) nil)
      1 (Triple. (.-s _) v (.-o _) nil)
      2 (Triple. (.-s _) (.-p _) v nil)
      (swizzle-assoc* _ {\s 0 \p 1 \o 2} k v)))
#+END_SRC
*** Constructor
#+BEGIN_SRC clojure :noweb-ref triple
  (defn triple
    ([s p o] (Triple. s p o nil))
    ([t] (if (instance? Triple t) t (let [[s p o] t] (Triple. s p o nil)))))
#+END_SRC

** In-memory stores

*** Classic 3-index implementation
#+BEGIN_SRC clojure :noweb-ref memstore
  (defrecord PlainMemoryStore [spo pos osp size]
    PStatementAccess
    (add-statement
      [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil)) _
        (let [s (get (find spo s) 0 s)
              p (get (find pos p) 0 p)
              o (get (find osp o) 0 o)
              t (Triple. s p o nil)]
          (PlainMemoryStore.
           (update-in spo [s p] d/set-conj t)
           (update-in pos [p o] d/set-conj t)
           (update-in osp [o s] d/set-conj t)
           (inc size)))))
    (add-bulk [_ statements]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs statements]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur changed? spo pos osp size (next xs))
              (let [s (get (find spo s) 0 s)
                    p (get (find pos p) 0 p)
                    o (get (find osp o) 0 o)
                    t (Triple. s p o nil)]
                (recur
                 true
                 (update-in spo [s p] d/set-conj t)
                 (update-in pos [p o] d/set-conj t)
                 (update-in osp [o s] d/set-conj t)
                 (inc size)
                 (next xs)))))
          (if changed?
            (PlainMemoryStore. spo pos osp size)
            _))))
    (remove-statement [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil))
        (PlainMemoryStore.
         (remove-from-index spo s p t)
         (remove-from-index pos p o t)
         (remove-from-index osp o s t)
         (dec size))
        _))
    (remove-bulk [_ statements]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs statements]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur
               true
               (remove-from-index spo s p t)
               (remove-from-index pos p o t)
               (remove-from-index osp o s t)
               (dec size)
               (next xs))
              (recur changed? spo pos osp size (next xs))))
          (if changed?
            (PlainMemoryStore. spo pos osp size)
            _))))
    (update-statement [_ s1 s2]
      (add-statement (remove-statement _ s1) s2))
    (remove-subject [_ s]
      (remove-bulk _ (select _ s nil nil)))

    PModel
    (subject? [_ x]
      (if (spo x) x))
    (predicate? [_ x]
      (if (pos x) x))
    (object? [_ x]
      (if (osp x) x))
    (indexed? [_ x]
      (if (or (spo x) (pos x) (osp x)) x))
    (subjects [_] (keys spo))
    (predicates [_] (keys pos))
    (objects [_] (keys osp))
    (model-size [_] size)
    (select [_]
      (select _ nil nil nil))
    (select
      [_ s p o]
      (if s
        (if p
          (if o
            ;; s p o
            (let [t (triple s p o)]
              (if (-> spo (get s nil) (get p nil) (get t nil)) [t]))
            ;; s p nil
            (-> spo (get s nil) (get p nil)))
          ;; s nil o / s nil nil
          (if o
            (-> osp (get o nil) (get s nil))
            (->> (spo s) vals (apply concat))))
        (if p
          (if o
            ;; nil p o
            (-> pos (get p nil) (get o nil))
            ;; nil p nil
            (->> (pos p) vals (apply concat)))
          (if o
            ;; nil nil o
            (->> (osp o) vals (apply concat))
            ;; nil nil nil
            (->> spo vals (mapcat vals) (apply concat))))))

  PAliasModelSupport
  (rewrite-alias
   [_ a b] (rewrite-alias-naive _ a b)))
#+END_SRC

*** Store with alias support

Some use cases require support for aliased resources stored in
triples. For example in RDF resources can be explicitly declared as
equal via an =owl:sameAs= relationship.

The =AliasMemoryStore= defined below achieves this goal by wrapping an
existing triplestore and combines it with an Union Find index to allow
registration of aliases and queries using them.

Union Find is based on the concept of disjoint sets of connected
components. For each component (set) a single canonical value is
chosen. In the case of the =AliasMemoryStore= this means any triples
containing aliased values will be rewritten to contain only canonical
values. This happens with already existing triples and newly added
ones. Aliases can be defined and removed at any time, although it's
more efficient to declare aliases before inserting new statements to
avoid major rewrite operations.

#+BEGIN_SRC clojure :noweb-ref alias-store
  (defrecord AliasMemoryStore [store aliases]
    PStatementAccess
    (add-statement
      [_ [s p o]]
      (let [t [(or (u/canonical aliases s) s)
               (or (u/canonical aliases p) p)
               (or (u/canonical aliases o) o)]]
        (AliasMemoryStore. (add-statement store t) aliases)))
    (add-bulk
      [_ statements]
      (loop [store store, xs statements]
        (if xs
          (let [[s p o] (first xs)
                t [(or (u/canonical aliases s) s)
                   (or (u/canonical aliases p) p)
                   (or (u/canonical aliases o) o)]]
            (recur (add-statement store t) (next xs)))
          (AliasMemoryStore. store aliases))))

    PModel
    (select
      [_] (select _ nil nil nil))
    (select
      [_ s p o]
      (let [s (or (u/canonical aliases s) s)
            p (or (u/canonical aliases p) p)
            o (or (u/canonical aliases o) o)]
        (select store s p o)))

    u/PUnionFind
    (canonical [_ p] (u/canonical aliases p))
    (canonical? [_ p] (u/canonical? aliases p))
    (component [_ p] (u/component aliases p))
    (disjoint-components [_] (u/disjoint-components aliases))
    (register [_ p] (AliasMemoryStore. store (u/register aliases p)))
    (unregister
      [_ p]
      (if (u/canonical? aliases p)
        (let [q (first (disj (u/component aliases p) p))
              aliases (u/unregister aliases p)
              store (if q (rewrite-alias store p q) store)]
          (AliasMemoryStore. store aliases))
        (AliasMemoryStore. store (u/unregister aliases p))))
    (unified? [_ p q] (u/unified? aliases p q))
    (union
      [_ p q]
      (if (and p q)
        (let [aliases (u/union aliases p q)
              canon (u/canonical aliases p)
              store (if (= p canon)
                      (rewrite-alias store q canon)
                      (rewrite-alias store p canon))]
          (AliasMemoryStore. store aliases))
        (err/illegal-arg! (str "aliases must be both non-nil values: " [p q])))))
#+END_SRC
*** Triple graph (WIP)

Currently highly inefficient (4-5x slower than =PlainMemoryStore=),
but still thinking this approach of treating triples (incl. with
wildcards) as graph, might have better milage later when solving query
joins...

#+BEGIN_SRC clojure :noweb-ref memstore
  (defprotocol PNode
    (get-children [_])
    (add-child [_ c])
    (remove-child [_ c]))

  (defprotocol PGraph
    (add-node [_ n] [_ n parents])
    (get-node [_ t])
    (get-ids [_])
    (get-nodes [_]))

  (deftype TripleNode [triple ^:volatile-mutable children]
    PNode
    (get-children [_] children)
    (add-child [_ c] (set! children (conj (or children #{}) c)) _)
    (remove-child [_ c] (set! children (disj children c)) _)

    Object
    (toString [_] (str (pr-str triple) " " (pr-str children))))

  (declare select-tg*)

  (deftype TripleGraph [nodes ids next-id]
    Object
    (toString
      [_] (str ":nodes " (pr-str nodes)
               " :ids " (pr-str ids)
               " :next " next-id))

    PGraph
    (add-node
      [_ n] (add-node _ n nil))
    (add-node
      [_ n parents]
      (let [g (TripleGraph.
               (assoc nodes next-id n)
               (assoc ids (.-triple  ^TripleNode n) next-id)
               (inc next-id))]
        (when (seq parents)
          (doseq [^TripleNode p parents]
            (add-child p next-id)))
        g))
    (get-node
      [_ t] (nodes (ids t)))

    PStatementAccess
    (add-statement
      [_ [s p o :as t]]
      (if-not (ids t)
        (let [id (.-next-id _)
              ^TripleGraph g (add-node _ (TripleNode. t nil) nil)
              index-branch (fn [g patterns]
                             (loop [^TripleGraph g g, id id, ps patterns]
                               (if ps
                                 (let [id' ((.-ids g) (first ps))]
                                   (if id'
                                     (do
                                       (add-child ^TripleNode ((.-nodes g) id') id)
                                       g)
                                     (recur
                                      (add-node g (TripleNode. (first ps) #{id}) nil)
                                      (.-next-id g)
                                      (next ps))))
                                 g)))]
          (-> (index-branch g [[s p nil] [s nil nil] [nil nil nil]])
              (index-branch [[nil p o] [nil p nil]])
              (index-branch [[s nil o] [nil nil o]])
              ))
        _))

    PModel
    (select
      [_ s p o]
      (persistent! (select-tg* nodes (ids [s p o]) (transient [])))))

  (defn- select-tg*
    [nodes id acc]
    (let [^TripleNode n (nodes id)]
      (if n
        (let [c (get-children n)]
          (if c
            (reduce #(select-tg* nodes %2 %) acc c)
            (conj! acc (.-triple n))))
        acc)))

  (defn triple-graph
    []
    (let [root (TripleNode. [nil nil nil] nil)]
      (add-node (TripleGraph. {} {} 0) root)))
#+END_SRC
**** Old add-statement
#+BEGIN_SRC clojure
  (add-statement
   [_ [s p o :as t]]
   (let [[_ t1s] (if-let [n (nodes (ids [s nil nil]))]
                   [_ n] (let [n (index-node [s nil nil])] [(add-node _ n [(nodes 0)]) n]))
         [_ t1p] (if-let [n (nodes (ids [nil p nil]))]
                   [_ n] (let [n (index-node [nil p nil])] [(add-node _ n) n]))
         [_ t1o] (if-let [n (nodes (ids [nil nil o]))]
                   [_ n] (let [n (index-node [nil nil o])] [(add-node _ n) n]))
         [_ t2sp] (if-let [n (nodes (ids [s p nil]))]
                    [_ n] (let [n (index-node [s p nil])] [(add-node _ n [t1s]) n]))
         [_ t2po] (if-let [n (nodes (ids [nil p o]))]
                    [_ n] (let [n (index-node [nil p o])] [(add-node _ n [t1p]) n]))
         [_ t2so] (if-let [n (nodes (ids [s nil o]))]
                    [_ n] (let [n (index-node [s nil o])] [(add-node _ n [t1o]) n]))]
     (add-node _ (index-node t) [t2sp t2so t2po])))
#+END_SRC
*** Constructors
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-store
    [& triples]
    (add-bulk (PlainMemoryStore. (hash-map) (hash-map) (hash-map) 0) triples))

  (defn alias-store
    [store aliases & triples]
    (add-bulk (reduce (partial apply u/union) (AliasMemoryStore. store (u/disjoint-set)) aliases) triples))
#+END_SRC

** Multi-store dataset

*** Type implementation
#+BEGIN_SRC clojure :noweb-ref dataset
  (defrecord PlainDataset [models]
    PStatementAccess
    (add-statement [_ s]
      (add-statement _ :default s))
    (add-statement [_ g s]
      (update-in _ [:models g] add-statement s))
    (add-bulk [_ statements]
      (add-bulk _ :default statements))
    (add-bulk [_ g statements]
      (update-in _ [:models g] add-bulk statements))
    (remove-statement [_ s]
      (remove-statement _ :default s))
    (remove-statement [_ g s]
      (update-in _ [:models g] remove-statement s))
    (remove-bulk [_ statements]
      (remove-bulk _ :default statements))
    (remove-bulk [_ g statements]
      (update-in _ [:models g] remove-bulk statements))
    (remove-subject [_ s]
      (remove-subject _ :default s))
    (remove-subject [_ g s]
      (update-in _ [:models g] remove-subject s))

    PModel
    (select [_]
      (select _ nil nil nil))
    (select [_ s p o]
      (mapcat #(select % s p o) (vals models)))
    (select [_ g s p o]
      (if-let [g (models g)] (select g s p o)))
    (subject? [_ x]
      (some #(subject? % x) (vals models)))
    (predicate? [_ x]
      (some #(predicate? % x) (vals models)))
    (object? [_ x]
      (some #(object? % x) (vals models)))
    (indexed? [_ x]
      (some #(indexed? % x) (vals models)))
    (subjects [_]
      (set (mapcat subjects (vals models))))
    (predicates [_]
      (set (mapcat predicates (vals models))))
    (objects [_]
      (set (mapcat objects (vals models))))
    (model-size [_]
      (reduce + (map model-size (vals models))))

    PDataset
    (update-model [_ id m]
      (assoc-in _ [:models id] m))
    (remove-model [_ id]
      (update-in _ [:models] dissoc id))
    (get-model [_ id]
      (models id)))
#+END_SRC

*** Constructor
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-dataset
    [& {:as models}]
    (PlainDataset. (assoc models :default (plain-store))))
#+END_SRC

** Clojure collection conversion

Using the =PModelConvert= protocol defined above, we can provide a
mechanism to automatically convert Clojure collections into a
triplestore. Of course, such an approach will involve some assumptions
about the internal structure of these collections, but the
implementations below are quite flexible and allow for very succinct
definitions of graph structures by specifying shared subjects,
predicates or objects within a given triple pattern.

*** Maps

To convert maps into a flat sequence of triples, the converter assumes
the data layout shown below. Unlike with sequences (discussed next),
which allow multiple subjects, predicates or objects per pattern, for
maps we can only support multiple object values for a given pair of
subject/predicate:

#+BEGIN_SRC clojure
  (as-model
   {:s1 {:p1 [:s2 :s3 :s4] :p2 23}
    :s2 {:p2 "foo"}
    :s3 {:p3 :s1}})

  ;; => [[:s1 :p1 :s2] [:s1 :p1 :s3] [:s1 :p1 :s4] [:s1 :p2 23] ...]
#+END_SRC

The map converter then simply flattens each SP tuple:

#+BEGIN_SRC clojure :noweb-ref convert
  (defn triple-seq-associative
    "Converts a single nested map into a seq of triples.
    Each key must have another map as value. Toplevel keys become
    subjects, value map keys predicates, inner map values objects. Each
    predicate key can define a seq of values to produce multiple
    triples."
    [coll]
    (mapcat
     (fn [[s v]]
       (mapcat
        (fn [[p o]]
          (if (coll? o)
            (mapv (fn [o] [s p o]) o)
            [[s p o]]))
        v))
     coll))
#+END_SRC

*** Sequential collections

Clojure sequences offer more flexibility than maps to encode graph
structures and furthermore can contain maps themselves. The
conversion supports any mixture of formats shown below by computing
the cartesian product of each individual pattern to produce a flat
sequence of triples. If a sequence item is a map, it will be converted
with the =triple-seq-associative= fn.

#+BEGIN_SRC clojure
  (as-model
   '[[s p o]                     ;; => [s p o]
     [s p [o1 o2]]               ;; => [s p o1] [s p o2]
     [s [p1 p2] o]               ;; => [s p1 o] [s p2 o]
     [s [p1 p2] [o1 o2]]         ;; => [s p1 o1] [s p2 o1] [s p1 o2] [s p2 o2]
     [[s1 s2] p o]               ;; => [s1 p o] [s2 p o]
     [[s1 s2] [p1 p2] o]         ;; => [s1 p1 o] [s1 p2 o] [s2 p1 o] [s2 p2 o]
     [[s1 s2] [p1 p2] [o1 o2]]]) ;; => [s1 p1 o1] [s1 p2 o2] [s2 p1 o1] ...

  (as-model
   '[{s1 {p1 [o1 o2]}            ;; => [s1 p1 o1] [s1 p1 o2]
      s2 {p1 [o3 o4]}}           ;; => [s2 p1 o3] [s2 p1 o4]
     {s1 {p2 o1, p3 o5}}])       ;; => [s1 p2 o1] [s1 p3 o5]
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref convert
  (defn triple-seq-sequential

   [coll]
   (mapcat
    (fn [triple]
      (if (map? triple)
        (triple-seq-associative triple)
        (->> triple
             (map #(if (sequential? %) % [%]))
             (apply d/cartesian-product))))
    coll))
#+END_SRC

*** Protocol implementations

#+BEGIN_SRC clojure :noweb-ref convert
  (extend-protocol PModelConvert

    ,#+clj  clojure.lang.Sequential
    ,#+cljs ISequential
    (as-model [_] (apply plain-store (triple-seq-sequential _)))

    ,#+clj  clojure.lang.IPersistentMap
    ,#+cljs IMap
    (as-model [_] (apply plain-store (triple-seq-associative _)))
    
    )
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.core
    (:refer-clojure :exclude [object? indexed?])
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.data.unionfind :as u]
     [thi.ng.common.error :as err]
     ,#+clj [clojure.pprint]
     ,#+clj [clojure.core.protocols :as cp]))

  <<protos>>

  <<helpers>>

  (declare swizzle swizzle-assoc)

  <<triple>>

  <<memstore>>

  <<alias-store>>

  <<dataset>>

  <<ctors>>

  <<convert>>
#+END_SRC
