#+SETUPFILE: setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingtriocore][Namespace: thi.ng.trio.core]]
     - [[#protocol-definitions][Protocol definitions]]
         - [[#ptripleseq][PTripleSeq]]
         - [[#pmodelconvert][PModelConvert]]
         - [[#pmodel][PModel]]
         - [[#pdataset][PDataset]]
         - [[#ptripleaccess][PTripleAccess]]
         - [[#paliasmodelsupport][PAliasModelSupport]]
         - [[#pmodelupdatehooks][PModelUpdateHooks]]
     - [[#helper-functions][Helper functions]]
     - [[#triple-datatype][Triple datatype]]
         - [[#templates][Templates]]
         - [[#implementation][Implementation]]
         - [[#override-print-methods][Override print methods]]
         - [[#swizzling][Swizzling]]
         - [[#constructor][Constructor]]
     - [[#in-memory-stores][In-memory stores]]
         - [[#classic-3-index-implementation][Classic 3-index implementation]]
         - [[#store-with-alias-support][Store with alias support]]
         - [[#triple-graph-experimental-incomplete][Triple graph (experimental, incomplete)]]
         - [[#constructors][Constructors]]
     - [[#multi-store-dataset][Multi-store dataset]]
         - [[#type-implementation][Type implementation]]
         - [[#constructor][Constructor]]
     - [[#clojure-collection-conversion][Clojure collection conversion]]
         - [[#maps][Maps]]
         - [[#sequential-collections][Sequential collections]]
         - [[#protocol-implementations][Protocol implementations]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.trio.core

This namespace provides various protocols for the low-level triple
store API, as well as a persistent in-memory store implementation and
a flexible dataset type to aggregate models/stores and query multiple
at once.

** Protocol definitions

*** PTripleSeq

This protocol is used to easily convert Clojure collections into a
triple sequence. Implementations are provided for sequences & maps
further below. This protocol is also used by the =PModelConvert=
implementations.

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PTripleSeq
   (triple-seq [_]))
#+END_SRC

*** PModelConvert

This protocol is used to easily convert Clojure collections into an
triplestore and so allow the query engine to operate directly on these
collections. Implementations are provided for sequences & maps further
below.

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PModelConvert
   (as-model [_]))
#+END_SRC

*** PModel

This protocol defines various accessors & predicate fns which must be
implemented by a triple store in order to allow the [[query.org][trio query engine]]
to act on it.

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PModel
    (select [_] [_ s p o] [_ g s p o])
    (subjects [_])
    (predicates [_])
    (objects [_])
    (subject? [_ x])
    (predicate? [_ x])
    (object? [_ x])
    (indexed? [_ x])
    (model-size [_]))
#+END_SRC

The =select= method is plays the main role here and is used to perform
low-level pattern match queries on a triplestore. Given any
combination of subject, predicate or object, the method performs a
search and returns all matching triples. The overall contract is that
if any SPO arg is =nil=, then this triple element matches anything.
Hence, there're eight possible variations to match triples:

#+BEGIN_SRC clojure
  ;; match all triples
  (select store nil nil nil)

  ;; match all triples w subject = :s
  (select store :s nil nil)

  ;; match all triples w/ pred = :p
  (select store nil :p nil)

  ;; match all triples w/ obj = :o
  (select store nil nil :o)

  ;; match all triples w/ subj = :s AND pred = :p
  (select store :s :p nil)

  ;; match all triples w/ subj= :s AND obj = :o
  (select store :s nil :o)

  ;; match all triples w/ pred = :p AND obj = :o
  (select store nil :p :o)

  ;; match only given triple [:s :p :o]
  (select store :s :p :o)
#+END_SRC

*** PDataset

In trio terminology, a dataset constitutes a triplestore, which
logically combines a number of other (independent) =PModel=
implementations. =PDataset= implementations *must* provide a =PModel=
implementation too and any queries run over a dataset will produce a
combined result from all included models. In addition, a dataset
*must* provide a =select= implementation with an extra graph arg to
directly query a specific model, rather than all.

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PDataset
    (remove-model [_ id])
    (update-model [_ id m])
    (get-model [_ id]))
#+END_SRC

*** PTripleAccess

This protocol defines accessors to add, update and remove triples from
a store. Bulk operations are defined, in order to allow optimized
implementations relying on connections to external storage layers.

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PTripleAccess
    (add-triple [_ s] [_ g s])
    (add-triples [_ triples] [_ g triples])
    (remove-triple [_ s] [_ g s])
    (remove-triples [_ triples] [_ g triples])
    (update-triple [_ s s'] [_ g s s'])
    (remove-subject [_ s] [_ g s]))
#+END_SRC

*** PAliasModelSupport

This is an experimental feature to support triplestore implementations
which allow the aliasing/renaming of individual triple elements and
provide potentially optimized solutions. See [[#store-with-alias-support][Store with alias support]]
for more details.

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PAliasModelSupport
    (rewrite-alias [_ a b]))
#+END_SRC

*** PModelUpdateHooks

This protocol allows for the injection of middleware during model
updates. There're two kinds of hooks, pre-commit and post-commit and
both are triggered for each single triple added or removed.

Each hook is a pair of functions called with the current model
instance and triple. The first fn is called during an add operation,
the other during remove.

**** Example

#+BEGIN_SRC clojure
  (def g
    (-> (plain-store)
        (add-post-commit-hook
         [(fn [g t] (prn :added t))
          (fn [g t] (prn :removed t))])))

  (add-triple g [:s :p :o])
  ;; => :added [:s :p :o]
#+END_SRC

**** Definition

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PModelUpdateHooks
    (add-pre-commit-hook [_ [add remove]])
    (add-post-commit-hook [_ [add remove]])
    (remove-pre-commit-hook [_ [add remove]])
    (remove-post-commit-hook [_ [add remove]]))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn- remove-from-index
    [idx i1 i2 i3]
    (let [kv (idx i1)
          v (disj (kv i2) i3)
          kv (if (seq v) kv (dissoc kv i2))]
      (if (seq kv)
        (if (seq v)
          (assoc-in idx [i1 i2] v)
          (assoc idx i1 kv))
        (dissoc idx i1))))

  (defn- rewrite-alias*
    [store pred id p q]
    (if (pred store p)
      (let [xs (apply select store (assoc [nil nil nil] id p))
            store (remove-triples store xs)]
        (add-triples store (map #(assoc % id q) xs)))
      store))

  (defn rewrite-alias-naive
    [store p q]
    (-> store
        (rewrite-alias* subject?   0 p q)
        (rewrite-alias* predicate? 1 p q)
        (rewrite-alias* object?    2 p q)))

  (defn trace [prefix x] (prn prefix x) x)
#+END_SRC

** Triple datatype

The triplestore implementations defined in this namespace use a
custom/optimized 3-element vector type to store triples internally.
This =Triple= type can be used like a normal vector since it
implements all necessary Clojure protocols. In addition to using
numeric indices (0..2) to refer to elements, the keywords =:s=, =:p=
and =:o= can be used alternatively. Furthermore, the =Triple= type
supports swizzling to look up, edit and/or change the order of elements:

#+BEGIN_SRC clojure
  (def t (triple 'karsten 'nickname 'toxi))

  (:s t)   ; => karsten
  (:p t)   ; => nickname
  (:o t)   ; => toxi
  (:so t)  ; => [karsten toxi]
  (:ops t) ; => [toxi nickname karsten]

  (assoc t :p 'same-as)        ; => [karsten same-as toxi]
  (assoc t :po '[author trio]) ; => [karsten author trio]
  (assoc t :op '[trio author]) ; => [karsten author trio]
#+END_SRC

*** Templates

In order to deduplicate shared code between both the Clojure &
ClojureScript protocol implementations, we first define a few snippets
as re-usable templates, which are injected in the appropriate places
of the code.

**** apply
#+NAME: tpl-apply
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string "{{fn}}" fn
  "(condp = (count args)
    1 ({{fn}} _ (first args) nil)
    2 ({{fn}} _ (first args) (second args))
    (err/arity-error! (count args)))")
#+END_SRC
**** assocN
#+BEGIN_SRC clojure :noweb-ref tpl-assoc-n
  (case (int k)
    0 (Triple. v p o nil)
    1 (Triple. s v o nil)
    2 (Triple. s p v nil)
    (err/key-error! k))
#+END_SRC
**** containsKey
#+BEGIN_SRC clojure :noweb-ref tpl-contains-key
  (not (nil? (#{0 1 2 :s :p :o} k)))
#+END_SRC
**** equals / equiv
#+NAME: tpl-equals
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string
   "{{fn}}" fn
   "(if (instance? Triple x)
      (and ({{fn}} s (.-s ^Triple x))
           ({{fn}} p (.-p ^Triple x))
           ({{fn}} o (.-o ^Triple x)))
      (and (instance? java.util.Collection x)
           (== 3 (count x))
           ({{fn}} s (nth x 0))
           ({{fn}} p (nth x 1))
           ({{fn}} o (nth x 2))))")
#+END_SRC
**** nth w/ error
#+BEGIN_SRC clojure :noweb-ref tpl-nth-err
  (case (int k) 0 s, 1 p, 2 o, (err/key-error! k))
#+END_SRC
**** nth w/ notfound
#+BEGIN_SRC clojure :noweb-ref tpl-nth-nf
  (case (int k) 0 s, 1 p, 2 o, nf)
#+END_SRC
**** compare
#+BEGIN_SRC clojure :noweb-ref tpl-compare
  (if (instance? Triple x)
    (let [c (compare s (.-s ^Triple x))]
      (if (== 0 c)
        (let [c (compare p (.-p ^Triple x))]
          (if (== 0 c)
            (compare o (.-o ^Triple x))
            c))
        c))
    (let [c (count x)]
      (if (== 3 c) (compare x _) (- 3 c))))
#+END_SRC
**** hashCode
#+BEGIN_SRC clojure :noweb-ref tpl-hashcode
  (-> 31
      (unchecked-add-int (hash s))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash p))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash o)))
#+END_SRC
**** rest
#+BEGIN_SRC clojure :noweb-ref tpl-rest
  (cons p (cons o nil))
#+END_SRC
**** rseq
#+BEGIN_SRC clojure :noweb-ref tpl-rseq
  (Triple. o p s nil)
#+END_SRC
**** reduce
#+BEGIN_SRC clojure :noweb-ref tpl-reduce
  (let [acc (f s p)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc o)]
        (if (reduced? acc)
          @acc
          acc))))
#+END_SRC
**** reduce w/ init
#+BEGIN_SRC clojure :noweb-ref tpl-reduce-start
  (let [acc (f start s)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc p)]
        (if (reduced? acc)
          @acc
          (let [acc (f acc o)]
            (if (reduced? acc)
              @acc
              acc))))))
#+END_SRC

*** Implementation
#+BEGIN_SRC clojure :noweb-ref triple
  (deftype Triple
    #+clj  [s p o ^:unsynchronized-mutable __hash]
    #+cljs [s p o ^:mutable __hash]
#+END_SRC
**** Clojure
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle _ k nf))

  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
          [_] (.invoke ^clojure.lang.IFn _))

  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle _ k nf))
  ,#+clj (applyTo
         [_ args]
         <<tpl-apply(fn="swizzle")>>)

  ,#+clj clojure.lang.IPersistentVector
  ,#+clj clojure.lang.Associative
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] <<tpl-contains-key>>)
  ,#+clj (entryAt
         [_ k] (clojure.lang.MapEntry. k <<tpl-nth-err>>))
  ,#+clj (assoc
            [_ k v] (swizzle-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         <<tpl-assoc-n>>)

  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list s p o)))
  ,#+clj (toArray
         [_] (object-array _))
  ,#+clj (size
         [_] 3)

  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] s)
  ,#+clj (next
         [_] <<tpl-rest>>)
  ,#+clj (more
         [_] <<tpl-rest>>)
  ,#+clj (cons
         [_ x] [s p o x])
  ,#+clj (peek
         [_] o)
  ,#+clj (pop
         [_] [s p])
  ,#+clj (rseq
         [_] <<tpl-rseq>>)
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ k] <<tpl-nth-err>>)
  ,#+clj (nth
         [_ k nf] <<tpl-nth-nf>>)
  ,#+clj (equiv
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equiv")>>)
  ,#+clj (equals
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equals")>>)
  ,#+clj (hashCode
         [_]
         <<tpl-hashcode>>)

  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         (or __hash (set! __hash
                          (mix-collection-hash
                           <<tpl-hashcode>>
                           3))))

  ,#+clj Comparable
  ,#+clj (compareTo
         [_ x]
         <<tpl-compare>>)

  ,#+clj cp/InternalReduce
  ,#+clj (internal-reduce
         [_ f start]
         <<tpl-reduce-start>>)

  ,#+clj cp/CollReduce
  ,#+clj (coll-reduce
         [_ f]
         <<tpl-reduce>>)
  ,#+clj (coll-reduce
         [_ f start]
         <<tpl-reduce-start>>)

  ,#+clj Object
  ,#+clj (toString
         [_]
         (.toString
          (doto (StringBuilder. "[")
            (.append (pr-str s))
            (.append " ")
            (.append (pr-str p))
            (.append " ")
            (.append (pr-str o))
            (.append "]"))))
#+END_SRC
**** ClojureScript protocols
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Triple. s p o __hash))

  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle _ k nf))

  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle _ k nf))

  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)

  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] <<tpl-contains-key>>)
  ,#+cljs (-assoc
          [_ k v] (swizzle-assoc _ k v))

  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          <<tpl-assoc-n>>)

  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] s)
  ,#+cljs (-rest
          [_] <<tpl-rest>>)

  ,#+cljs INext
  ,#+cljs (-next
          [_] <<tpl-rest>>)

  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)

  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] <<tpl-rseq>>)

  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ k] <<tpl-nth-err>>)
  ,#+cljs (-nth
          [_ k nf] <<tpl-nth-nf>>)

  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ x] [s p o x])

  ,#+cljs IStack
  ,#+cljs (-peek
          [_] o)
  ,#+cljs (-pop
          [_] [s p])

  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ x]
          <<tpl-compare>>)

  ,#+cljs IHash
  ,#+cljs (-hash
          [_]
          (or __hash
              (set! (.-__hash _)
                    (mix-collection-hash
                     (-> 31 (+ (hash s))
                         (bit-or 0)
                         (imul 31) (+ (hash p))
                         (bit-or 0)
                         (imul 31) (+ (hash o))
                         (bit-or 0))
                     3))))

  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ x]
          (if (instance? Triple x)
            (and (= s (.-s ^Triple x)) (= p (.-p ^Triple x)) (= o (.-o ^Triple x)))
            (and (sequential? x) (== 3 (count x))
                 (= s (nth x 0)) (= p (nth x 1)) (= o (nth x 2)))))

  ,#+cljs IReduce
  ,#+cljs (-reduce
          [coll f]
          <<tpl-reduce>>)
  ,#+cljs (-reduce
          [coll f start]
          <<tpl-reduce-start>>)

  ,#+cljs Object
  ,#+cljs (toString
          [_] (str "[" s " " p " " o "]"))
#+END_SRC

**** End of triple type
#+BEGIN_SRC clojure :noweb-ref triple
  )
#+END_SRC

*** Override print methods
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj (defmethod clojure.pprint/simple-dispatch Triple
    [^Triple o] ((get-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector) o))
  ,#+clj (defmethod print-method Triple [^Triple o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC

*** Swizzling
#+BEGIN_SRC clojure triple :noweb-ref triple
  (defn- lookup3
    [^Triple _ k nf]
    (case k
      \s (.-s _)
      \p (.-p _)
      \o (.-o _)
      (or nf (err/key-error! k))))

  (defn- swizzle
    [^Triple _ k default]
    (if (number? k)
      (case (int k)
        0 (.-s _)
        1 (.-p _)
        2 (.-o _)
        (or default (err/key-error! k)))
      (case k
        :s (.-s _)
        :p (.-p _)
        :o (.-o _)
        (let [n (name k) c (count n)]
          (case c
            2 [(lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)]
            3 (Triple.
               (lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)
               (lookup3 _ (nth n 2) default)
               nil)
            (or default (err/key-error! k)))))))

  (defn- swizzle-assoc*
    [_ keymap k v]
    (let [n (name k)
          c (count n)]
      (if (and (<= c (count keymap)) (== c (count v) (count (into #{} n))))
        (loop [acc (vec _), i 0, n n]
          (if n
            (recur (assoc acc (keymap (first n)) (v i)) (inc i) (next n))
            (Triple. (acc 0) (acc 1) (acc 2) nil)))
        (err/key-error! k))))

  (defn- swizzle-assoc
    [^Triple _ k v]
    (case k
      :s (Triple. v (.-p _) (.-o _) nil)
      :p (Triple. (.-s _) v (.-o _) nil)
      :o (Triple. (.-s _) (.-p _) v nil)
      0 (Triple. v (.-p _) (.-o _) nil)
      1 (Triple. (.-s _) v (.-o _) nil)
      2 (Triple. (.-s _) (.-p _) v nil)
      (swizzle-assoc* _ {\s 0 \p 1 \o 2} k v)))
#+END_SRC
*** Constructor
#+BEGIN_SRC clojure :noweb-ref triple
  (defn triple
    ([s p o] (Triple. s p o nil))
    ([t] (if (instance? Triple t) t (let [[s p o] t] (Triple. s p o nil)))))
#+END_SRC

** In-memory stores

*** Classic 3-index implementation

#+BEGIN_SRC clojure :noweb-ref memstore
  (defrecord PlainMemoryStore [spo pos osp size]
    PTripleAccess
    (add-triple
      [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil)) _
        (let [s (get (find spo s) 0 s)
              p (get (find pos p) 0 p)
              o (get (find osp o) 0 o)
              t (Triple. s p o nil)]
          (PlainMemoryStore.
           (update-in spo [s p] d/set-conj t)
           (update-in pos [p o] d/set-conj t)
           (update-in osp [o s] d/set-conj t)
           (inc size)))))
    (add-triples [_ triples]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs triples]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur changed? spo pos osp size (next xs))
              (let [s (get (find spo s) 0 s)
                    p (get (find pos p) 0 p)
                    o (get (find osp o) 0 o)
                    t (Triple. s p o nil)]
                (recur
                 true
                 (update-in spo [s p] d/set-conj t)
                 (update-in pos [p o] d/set-conj t)
                 (update-in osp [o s] d/set-conj t)
                 (inc size)
                 (next xs)))))
          (if changed?
            (PlainMemoryStore. spo pos osp size)
            _))))
    (remove-triple [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil))
        (PlainMemoryStore.
         (remove-from-index spo s p t)
         (remove-from-index pos p o t)
         (remove-from-index osp o s t)
         (dec size))
        _))
    (remove-triples [_ triples]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs triples]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur
               true
               (remove-from-index spo s p t)
               (remove-from-index pos p o t)
               (remove-from-index osp o s t)
               (dec size)
               (next xs))
              (recur changed? spo pos osp size (next xs))))
          (if changed?
            (PlainMemoryStore. spo pos osp size)
            _))))
    (update-triple [_ s1 s2]
      (add-triple (remove-triple _ s1) s2))
    (remove-subject [_ s]
      (remove-triples _ (select _ s nil nil)))

    PModel
    (subject? [_ x]
      (if (spo x) x))
    (predicate? [_ x]
      (if (pos x) x))
    (object? [_ x]
      (if (osp x) x))
    (indexed? [_ x]
      (if (or (spo x) (pos x) (osp x)) x))
    (subjects [_] (keys spo))
    (predicates [_] (keys pos))
    (objects [_] (keys osp))
    (model-size [_] size)
    (select [_]
      (select _ nil nil nil))
    (select
      [_ s p o]
      (if s
        (if p
          (if o
            ;; s p o
            (let [t (triple s p o)]
              (if (-> spo (get s nil) (get p nil) (get t nil)) [t]))
            ;; s p nil
            (-> spo (get s nil) (get p nil)))
          ;; s nil o / s nil nil
          (if o
            (-> osp (get o nil) (get s nil))
            (->> (spo s) vals (apply concat))))
        (if p
          (if o
            ;; nil p o
            (-> pos (get p nil) (get o nil))
            ;; nil p nil
            (->> (pos p) vals (apply concat)))
          (if o
            ;; nil nil o
            (->> (osp o) vals (apply concat))
            ;; nil nil nil
            (->> spo vals (mapcat vals) (apply concat))))))

  PAliasModelSupport
  (rewrite-alias
   [_ a b] (rewrite-alias-naive _ a b)))
#+END_SRC

*** Store with alias support

Some use cases require support for aliased resources stored in
triples. For example in RDF resources can be explicitly declared as
equal via an =owl:sameAs= relationship.

The =AliasMemoryStore= defined below achieves this goal by wrapping an
existing triplestore and combines it with an Union Find index to allow
registration of aliases and queries using them.

Union Find is based on the concept of disjoint sets of connected
components. For each component (set) a single canonical value is
chosen. In the case of the =AliasMemoryStore= this means any triples
containing aliased values will be rewritten to contain only canonical
values. This happens with already existing triples and newly added
ones. Aliases can be defined and removed at any time, although it's
more efficient to declare aliases before inserting new triples to
avoid major rewrite operations.

#+BEGIN_SRC clojure :noweb-ref alias-store
  (defrecord AliasMemoryStore [store aliases]
    PTripleAccess
    (add-triple
      [_ [s p o]]
      (let [t [(or (u/canonical aliases s) s)
               (or (u/canonical aliases p) p)
               (or (u/canonical aliases o) o)]]
        (AliasMemoryStore. (add-triple store t) aliases)))
    (add-triples
      [_ triples]
      (loop [store store, xs triples]
        (if xs
          (let [[s p o] (first xs)
                t [(or (u/canonical aliases s) s)
                   (or (u/canonical aliases p) p)
                   (or (u/canonical aliases o) o)]]
            (recur (add-triple store t) (next xs)))
          (AliasMemoryStore. store aliases))))

    PModel
    (subject? [_ x]
      (subject? store (or (u/canonical aliases x) x)))
    (predicate? [_ x]
      (predicate? store (or (u/canonical aliases x) x)))
    (object? [_ x]
      (object? store (or (u/canonical aliases x) x)))
    (indexed? [_ x]
      (indexed? store (or (u/canonical aliases x) x)))
    (subjects [_] (subjects store))
    (predicates [_] (predicates store))
    (objects [_] (objects store))
    (model-size [_] (model-size store))
    (select
      [_] (select _ nil nil nil))
    (select
      [_ s p o]
      (let [s (or (u/canonical aliases s) s)
            p (or (u/canonical aliases p) p)
            o (or (u/canonical aliases o) o)]
        (select store s p o)))

    u/PUnionFind
    (canonical [_ p] (u/canonical aliases p))
    (canonical? [_ p] (u/canonical? aliases p))
    (component [_ p] (u/component aliases p))
    (disjoint-components [_] (u/disjoint-components aliases))
    (register [_ p] (AliasMemoryStore. store (u/register aliases p)))
    (unregister
      [_ p]
      (if (u/canonical? aliases p)
        (let [q (first (disj (u/component aliases p) p))
              aliases (u/unregister aliases p)
              store (if q (rewrite-alias store p q) store)]
          (AliasMemoryStore. store aliases))
        (AliasMemoryStore. store (u/unregister aliases p))))
    (unified? [_ p q] (u/unified? aliases p q))
    (union
      [_ p q]
      (if (and p q)
        (let [aliases (u/union aliases p q)
              canon (u/canonical aliases p)
              store (if (= p canon)
                      (rewrite-alias store q canon)
                      (rewrite-alias store p canon))]
          (AliasMemoryStore. store aliases))
        (err/illegal-arg! (str "aliases must be both non-nil values: " [p q])))))
#+END_SRC
*** Triple graph (experimental, incomplete)

Currently highly inefficient (4-5x slower than =PlainMemoryStore=),
but still thinking this approach of treating triples (incl. with
wildcards) as graph, might have better milage later when solving query
joins...

#+BEGIN_SRC clojure :noweb-ref memstore
  (defprotocol PNode
    (get-children [_])
    (add-child [_ c])
    (remove-child [_ c]))

  (defprotocol PGraph
    (add-node [_ n] [_ n parents])
    (get-node [_ t])
    (get-ids [_])
    (get-nodes [_]))

  (deftype TripleNode [triple ^:volatile-mutable children]
    PNode
    (get-children [_] children)
    (add-child [_ c] (set! children (conj (or children #{}) c)) _)
    (remove-child [_ c] (set! children (disj children c)) _)

    Object
    (toString [_] (str (pr-str triple) " " (pr-str children))))

  (declare select-tg*)

  (deftype TripleGraph [nodes ids next-id]
    Object
    (toString
      [_] (str ":nodes " (pr-str nodes)
               " :ids " (pr-str ids)
               " :next " next-id))

    PGraph
    (add-node
      [_ n] (add-node _ n nil))
    (add-node
      [_ n parents]
      (let [g (TripleGraph.
               (assoc nodes next-id n)
               (assoc ids (.-triple  ^TripleNode n) next-id)
               (inc next-id))]
        (when (seq parents)
          (doseq [^TripleNode p parents]
            (add-child p next-id)))
        g))
    (get-node
      [_ t] (nodes (ids t)))

    PTripleAccess
    (add-triple
      [_ [s p o :as t]]
      (if-not (ids t)
        (let [id (.-next-id _)
              ^TripleGraph g (add-node _ (TripleNode. t nil) nil)
              index-branch (fn [g patterns]
                             (loop [^TripleGraph g g, id id, ps patterns]
                               (if ps
                                 (let [id' ((.-ids g) (first ps))]
                                   (if id'
                                     (do
                                       (add-child ^TripleNode ((.-nodes g) id') id)
                                       g)
                                     (recur
                                      (add-node g (TripleNode. (first ps) #{id}) nil)
                                      (.-next-id g)
                                      (next ps))))
                                 g)))]
          (-> (index-branch g [[s p nil] [s nil nil] [nil nil nil]])
              (index-branch [[nil p o] [nil p nil]])
              (index-branch [[s nil o] [nil nil o]])
              ))
        _))

    PModel
    (select
      [_ s p o]
      (persistent! (select-tg* nodes (ids [s p o]) (transient [])))))

  (defn- select-tg*
    [nodes id acc]
    (let [^TripleNode n (nodes id)]
      (if n
        (let [c (get-children n)]
          (if c
            (reduce #(select-tg* nodes %2 %) acc c)
            (conj! acc (.-triple n))))
        acc)))

  (defn triple-graph
    []
    (let [root (TripleNode. [nil nil nil] nil)]
      (add-node (TripleGraph. {} {} 0) root)))
#+END_SRC
**** Old add-triple (ignore)
#+BEGIN_SRC clojure
  (add-triple
   [_ [s p o :as t]]
   (let [[_ t1s] (if-let [n (nodes (ids [s nil nil]))]
                   [_ n] (let [n (index-node [s nil nil])] [(add-node _ n [(nodes 0)]) n]))
         [_ t1p] (if-let [n (nodes (ids [nil p nil]))]
                   [_ n] (let [n (index-node [nil p nil])] [(add-node _ n) n]))
         [_ t1o] (if-let [n (nodes (ids [nil nil o]))]
                   [_ n] (let [n (index-node [nil nil o])] [(add-node _ n) n]))
         [_ t2sp] (if-let [n (nodes (ids [s p nil]))]
                    [_ n] (let [n (index-node [s p nil])] [(add-node _ n [t1s]) n]))
         [_ t2po] (if-let [n (nodes (ids [nil p o]))]
                    [_ n] (let [n (index-node [nil p o])] [(add-node _ n [t1p]) n]))
         [_ t2so] (if-let [n (nodes (ids [s nil o]))]
                    [_ n] (let [n (index-node [s nil o])] [(add-node _ n [t1o]) n]))]
     (add-node _ (index-node t) [t2sp t2so t2po])))
#+END_SRC
*** Constructors
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-store
    [& triples]
    (add-triples (PlainMemoryStore. (hash-map) (hash-map) (hash-map) 0) triples))

  (defn alias-store
    [store aliases & triples]
    (add-triples (reduce (partial apply u/union) (AliasMemoryStore. store (u/disjoint-set)) aliases) triples))
#+END_SRC

** Multi-store dataset

*** Type implementation

#+BEGIN_SRC clojure :noweb-ref dataset
  (defrecord PlainDataset [models]
    PTripleAccess
    (add-triple [_ s]
      (add-triple _ :default s))
    (add-triple [_ g s]
      (update-in _ [:models g] add-triple s))
    (add-triples [_ triples]
      (add-triples _ :default triples))
    (add-triples [_ g triples]
      (update-in _ [:models g] add-triples triples))
    (remove-triple [_ s]
      (remove-triple _ :default s))
    (remove-triple [_ g s]
      (update-in _ [:models g] remove-triple s))
    (remove-triples [_ triples]
      (remove-triples _ :default triples))
    (remove-triples [_ g triples]
      (update-in _ [:models g] remove-triples triples))
    (remove-subject [_ s]
      (remove-subject _ :default s))
    (remove-subject [_ g s]
      (update-in _ [:models g] remove-subject s))

    PModel
    (select [_]
      (select _ nil nil nil))
    (select [_ s p o]
      (mapcat #(select % s p o) (vals models)))
    (select [_ g s p o]
      (if-let [g (models g)] (select g s p o)))
    (subject? [_ x]
      (some #(subject? % x) (vals models)))
    (predicate? [_ x]
      (some #(predicate? % x) (vals models)))
    (object? [_ x]
      (some #(object? % x) (vals models)))
    (indexed? [_ x]
      (some #(indexed? % x) (vals models)))
    (subjects [_]
      (set (mapcat subjects (vals models))))
    (predicates [_]
      (set (mapcat predicates (vals models))))
    (objects [_]
      (set (mapcat objects (vals models))))
    (model-size [_]
      (reduce + (map model-size (vals models))))

    PDataset
    (update-model [_ id m]
      (assoc-in _ [:models id] m))
    (remove-model [_ id]
      (update-in _ [:models] dissoc id))
    (get-model [_ id]
      (models id)))
#+END_SRC

*** Constructor

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-dataset
    [& {:as models}]
    (PlainDataset. (assoc models :default (plain-store))))
#+END_SRC

** Clojure collection conversion

Using the =PTripleSeq= and =PModelConvert= protocols defined above, we
can provide a mechanism to automatically convert Clojure collections
into triple seqs or a triplestore. Of course, such an approach will
involve some assumptions about the internal structure of these
collections, but the implementations below are quite flexible and
allow for very succinct definitions of graph structures by specifying
shared subjects, predicates or objects within a given triple pattern.
The =PModelConvert= simply wraps the =PTripleSeq= implementation and
produces a new =PlainMemoryStore= with the supplied triples.

*Note:* The triple seqs produced are all lazy (using =mapcat=).

*** Maps

To convert maps into a flat sequence of triples, the converter assumes
the data layout shown below. Unlike with sequences (discussed next),
which allow multiple subjects, predicates or objects per pattern, for
maps we can only support multiple object values for a given pair of
subject/predicate:

#+BEGIN_SRC clojure
  (as-model
   {:s1 {:p1 [:s2 :s3 :s4] :p2 23}
    :s2 {:p2 "foo"}
    :s3 {:p3 :s1}})

  ;; => [[:s1 :p1 :s2] [:s1 :p1 :s3] [:s1 :p1 :s4] [:s1 :p2 23] ...]
#+END_SRC

The map converter then simply flattens each SP tuple:

#+BEGIN_SRC clojure :noweb-ref convert
  (defn triple-seq-associative
    "Converts a single nested map into a seq of triples.
    Each key must have another map as value. Toplevel keys become
    subjects, value map keys predicates, inner map values objects. Each
    predicate key can define a seq of values to produce multiple
    triples."
    [coll]
    (mapcat
     (fn [[s v]]
       (mapcat
        (fn [[p o]]
          (if (sequential? o)
            (mapv (fn [o] [s p o]) o)
            [[s p o]]))
        v))
     coll))
#+END_SRC

*** Sequential collections

Clojure sequences offer more flexibility than maps to encode graph
structures and furthermore can contain maps themselves. The
conversion supports any mixture of formats shown below by computing
the cartesian product of each individual pattern to produce a flat
sequence of triples. If a sequence item is a map, it will be converted
with the =triple-seq-associative= fn.

#+BEGIN_SRC clojure
  (as-model
   '[[s p o]                     ;; => [s p o]
     [s p [o1 o2]]               ;; => [s p o1] [s p o2]
     [s [p1 p2] o]               ;; => [s p1 o] [s p2 o]
     [s [p1 p2] [o1 o2]]         ;; => [s p1 o1] [s p2 o1] [s p1 o2] [s p2 o2]
     [[s1 s2] p o]               ;; => [s1 p o] [s2 p o]
     [[s1 s2] [p1 p2] o]         ;; => [s1 p1 o] [s1 p2 o] [s2 p1 o] [s2 p2 o]
     [[s1 s2] [p1 p2] [o1 o2]]]) ;; => [s1 p1 o1] [s1 p2 o2] [s2 p1 o1] ...

  (as-model
   '[{s1 {p1 [o1 o2]}            ;; => [s1 p1 o1] [s1 p1 o2]
      s2 {p1 [o3 o4]}}           ;; => [s2 p1 o3] [s2 p1 o4]
     {s1 {p2 o1, p3 o5}}])       ;; => [s1 p2 o1] [s1 p3 o5]
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref convert
  (defn triple-seq-sequential
   [coll]
   (mapcat
    (fn [triple]
      (if (map? triple)
        (triple-seq triple)
        (->> triple
             (map #(if (sequential? %) % [%]))
             (apply d/cartesian-product))))
    coll))
#+END_SRC

*** Protocol implementations

#+BEGIN_SRC clojure :noweb-ref convert
  (extend-protocol PTripleSeq
      ,,#+clj  clojure.lang.Sequential
      ,,#+cljs PersistentVector
      (triple-seq [_] (triple-seq-sequential _))
      ,,#+cljs List
      ,,#+cljs (triple-seq [_] (triple-seq-sequential _))
      ,,#+cljs LazySeq
      ,,#+cljs (triple-seq [_] (triple-seq-sequential _))
      ,,#+cljs IndexedSeq
      ,,#+cljs (triple-seq [_] (triple-seq-sequential _))
      ,,#+clj  clojure.lang.IPersistentMap
      ,,#+cljs PersistentHashMap
      (triple-seq [_] (triple-seq-associative _))
      ,,#+cljs PersistentArrayMap
      ,,#+cljs (triple-seq [_] (triple-seq-associative _)))

  (extend-protocol PModelConvert
    ,#+clj  clojure.lang.Sequential
    ,#+cljs PersistentVector
    (as-model [_] (apply plain-store (triple-seq-sequential _)))
    ,#+cljs List
    ,#+cljs (as-model [_] (apply plain-store (triple-seq-sequential _)))
    ,#+cljs LazySeq
    ,#+cljs (as-model [_] (apply plain-store (triple-seq-sequential _)))
    ,#+cljs IndexedSeq
    ,#+cljs (as-model [_] (apply plain-store (triple-seq-sequential _)))
    ,#+clj  clojure.lang.IPersistentMap
    ,#+cljs PersistentHashMap
    (as-model [_] (apply plain-store (triple-seq-associative _)))
    ,#+cljs PersistentArrayMap
    ,#+cljs (as-model [_] (apply plain-store (triple-seq-associative _))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.core
    (:refer-clojure :exclude [object? indexed?])
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.data.unionfind :as u]
     [thi.ng.common.error :as err]
     ,#+clj [clojure.pprint]
     ,#+clj [clojure.core.protocols :as cp]))

  <<protos>>

  <<helpers>>

  (declare swizzle swizzle-assoc)

  <<triple>>

  <<memstore>>

  <<alias-store>>

  <<dataset>>

  <<ctors>>

  <<convert>>
#+END_SRC
