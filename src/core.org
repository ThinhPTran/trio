#+SETUPFILE: setup.org

* Namespace: thi.ng.trio.core

This namespace provides various protocols for the low-level triple
store API, as well as a persistent in-memory store implementation and
a flexible dataset type to aggregate models/stores and query multiple
at once.

** Protocol definitions

*** PModel
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PModel
    (select [_] [_ s p o] [_ g s p o])
    (subjects [_])
    (predicates [_])
    (objects [_])
    (subject? [_ x])
    (predicate? [_ x])
    (object? [_ x])
    (indexed? [_ x])
    (model-size [_]))
#+END_SRC

*** PDataset
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PDataset
    (remove-model [_ id])
    (update-model [_ id f])
    (get-model [_ id]))
#+END_SRC

*** PStatementAccess
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PStatementAccess
    (add-statement [_ s] [_ g s])
    (add-bulk [_ statements] [_ g statements])
    (remove-statement [_ s] [_ g s])
    (remove-bulk [_ statements] [_ g statements])
    (update-statement [_ s s'] [_ g s s'])
    (remove-subject [_ s] [_ g s]))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn remove-from-index
    [idx i1 i2 i3]
    (let [kv (idx i1)
          v (disj (kv i2) i3)
          kv (if (seq v) kv (dissoc kv i2))]
      (if (seq kv)
        (if (seq v)
          (assoc-in idx [i1 i2] v)
          (assoc idx i1 kv))
        (dissoc idx i1))))

  (defn select-seq
    [coll statement-fn & [flt]]
    (mapcat
     (fn [inner]
       (map
        (statement-fn (inner 0))
        (if flt
          (filter flt (inner 1))
          (inner 1))))
     coll))
#+END_SRC

** Triple datatype
*** Protocol helpers
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj
  (defn map-entry
    [k v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry
      (key [_] k)
      (getKey [_] k)
      (val [_] v)
      (getValue [_] v)
      (hashCode [_]
        (-> 31
            (unchecked-add-int (hash k))
            (unchecked-multiply-int 31)
            (unchecked-add-int (hash v))))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals
              k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals
              v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC

*** Templates

In order to deduplicate shared code between both the Clojure &
ClojureScript protocol implementations, we first define a few snippets
as re-usable templates, which are injected in the appropriate places
of the code.

**** apply
#+NAME: tpl-apply
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string "{{fn}}" fn
  "(condp = (count args)
    1 ({{fn}} _ (first args) nil)
    2 ({{fn}} _ (first args) (second args))
    (err/arity-error! (count args)))")
#+END_SRC
**** assocN
#+BEGIN_SRC clojure :noweb-ref tpl-assoc-n
  (case (int k)
    0 (Triple. v p o nil)
    1 (Triple. s v o nil)
    2 (Triple. s p v nil)
    (err/key-error! k))
#+END_SRC
**** containsKey
#+BEGIN_SRC clojure :noweb-ref tpl-contains-key
  (not (nil? (#{0 1 2 :s :p :o} k)))
#+END_SRC
**** equals / equiv
#+NAME: tpl-equals
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string
   "{{fn}}" fn
   "(if (instance? Triple x)
      (and ({{fn}} s (.-s ^Triple x))
           ({{fn}} p (.-p ^Triple x))
           ({{fn}} o (.-o ^Triple x)))
      (and (instance? java.util.Collection x)
           (= 3 (count x))
           ({{fn}} s (nth x 0))
           ({{fn}} p (nth x 1))
           ({{fn}} o (nth x 2))))")
#+END_SRC
**** nth w/ error
#+BEGIN_SRC clojure :noweb-ref tpl-nth-err
  (case (int k) 0 s, 1 p, 2 o, (err/key-error! k))
#+END_SRC
**** nth w/ notfound
#+BEGIN_SRC clojure :noweb-ref tpl-nth-nf
  (case (int k) 0 s, 1 p, 2 o, nf)
#+END_SRC
**** compare
#+BEGIN_SRC clojure :noweb-ref tpl-compare
  (if (instance? Triple x)
    (let [c (compare s (.-s ^Triple x))]
      (if (== 0 c)
        (let [c (compare p (.-p ^Triple x))]
          (if (== 0 c)
            (compare o (.-o ^Triple x))
            c))
        c))
    (let [c (count x)]
      (if (== 3 c) (compare x _) (- 3 c))))
#+END_SRC
**** hashCode
#+BEGIN_SRC clojure :noweb-ref tpl-hashcode
  (-> 31
      (unchecked-add-int (hash s))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash p))
      (unchecked-multiply-int 31)
      (unchecked-add-int (hash o)))
#+END_SRC
**** rest
#+BEGIN_SRC clojure :noweb-ref tpl-rest
  (cons p (cons o nil))
#+END_SRC
**** rseq
#+BEGIN_SRC clojure :noweb-ref tpl-rseq
  (Triple. o p s nil)
#+END_SRC
*** Implementation
#+BEGIN_SRC clojure :noweb-ref triple
  (deftype Triple
    #+clj  [s p o ^:volatile-mutable __hash]
    #+cljs [s p o ^:mutable __hash]
#+END_SRC
**** Clojure
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle _ k nf))

  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
          [_] (.invoke ^clojure.lang.IFn _))

  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle _ k nf))
  ,#+clj (applyTo
         [_ args]
         <<tpl-apply(fn="swizzle")>>)

  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] <<tpl-contains-key>>)
  ,#+clj (entryAt
         [_ k] (map-entry k <<tpl-nth-err>>))
  ,#+clj (assoc
            [_ k v] (swizzle-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         <<tpl-assoc-n>>)

  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list s p o)))
  ,#+clj (toArray
         [_] (object-array _))
  ,#+clj (size
         [_] 3)

  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] s)
  ,#+clj (next
         [_] <<tpl-rest>>)
  ,#+clj (more
         [_] <<tpl-rest>>)
  ,#+clj (cons
         [_ x] [s p o x])
  ,#+clj (peek
         [_] o)
  ,#+clj (pop
         [_] [s p])
  ,#+clj (rseq
         [_] <<tpl-rseq>>)
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ k] <<tpl-nth-err>>)
  ,#+clj (nth
         [_ k nf] <<tpl-nth-nf>>)
  ,#+clj (equiv
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equiv")>>)
  ,#+clj (equals
         [_ x]
         <<tpl-equals(fn="clojure.lang.Util/equals")>>)
  ,#+clj (hashCode
         [_]
         <<tpl-hashcode>>)

  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         (or __hash (set! __hash
                          (mix-collection-hash
                           <<tpl-hashcode>>
                           3))))

  ,#+clj Comparable
  ,#+clj (compareTo
         [_ x]
         <<tpl-compare>>)

  ,#+clj Object
  ,#+clj (toString
         [_]
         (.toString
          (doto (StringBuilder. "[")
            (.append (pr-str s))
            (.append " ")
            (.append (pr-str p))
            (.append " ")
            (.append (pr-str o))
            (.append "]"))))
#+END_SRC
**** ClojureScript protocols
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Triple. s p o __hash))

  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle _ k nf))

  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle _ k nf))

  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)

  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] <<tpl-contains-key>>)
  ,#+cljs (-assoc
          [_ k v] (swizzle-assoc _ k v))

  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          <<tpl-assoc-n>>)

  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] s)
  ,#+cljs (-rest
          [_] <<tpl-rest>>)

  ,#+cljs INext
  ,#+cljs (-next
          [_] <<tpl-rest>>)

  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)

  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] <<tpl-rseq>>)

  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ k] <<tpl-nth-err>>)
  ,#+cljs (-nth
          [_ k nf] <<tpl-nth-nf>>)

  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ x] [s p o x])

  ,#+cljs IStack
  ,#+cljs (-peek
          [_] o)
  ,#+cljs (-pop
          [_] [s p])

  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ x]
          <<tpl-compare>>)

  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (or __hash (set! (.-__hash _) (hash-coll _))))

  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ x]
          (if (instance? Triple x)
            (and (= s (.-s ^Triple x)) (= p (.-p ^Triple x)) (= o (.-o ^Triple x)))
            (and (sequential? x) (= 3 (count x))
                 (= s (nth x 0)) (= p (nth x 1)) (= o (nth x 2)))))

  ,#+cljs Object
  ,#+cljs (toString
          [_] (str "[" s " " p " " o "]"))
#+END_SRC

**** End of triple type
#+BEGIN_SRC clojure :noweb-ref triple
  )
#+END_SRC

*** Override print methods
#+BEGIN_SRC clojure :noweb-ref triple
  ,#+clj (require 'clojure.pprint)
  ,#+clj (prefer-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector clojure.lang.ISeq)
  ,#+clj (defmethod print-method Triple [^Triple o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC

*** Swizzling
#+BEGIN_SRC clojure triple :noweb-ref triple
  (defn- lookup3
    [^Triple _ k nf]
    (case k
      \s (.-s _)
      \p (.-p _)
      \o (.-o _)
      (or nf (err/key-error! k))))

  (defn- swizzle
    [^Triple _ k default]
    (if (number? k)
      (case (int k)
        0 (.-s _)
        1 (.-p _)
        2 (.-o _)
        (or default (err/key-error! k)))
      (case k
        :s (.-s _)
        :p (.-p _)
        :o (.-o _)
        (let [n (name k) c (count n)]
          (case c
            2 [(lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)]
            3 (Triple.
               (lookup3 _ (nth n 0) default)
               (lookup3 _ (nth n 1) default)
               (lookup3 _ (nth n 2) default)
               nil)
            (or default (err/key-error! k)))))))

  (defn- swizzle-assoc*
    [_ keymap k v]
    (let [n (name k)
          c (count n)]
      (if (and (<= c (count keymap)) (== c (count v) (count (into #{} n))))
        (loop [acc (object-array 3), i 0, n n]
          (if n
            (recur (do (aset acc (keymap (first n)) (v i)) acc) (inc i) (next n))
            (Triple. (aget acc 0) (aget acc 1) (aget acc 2) nil)))
        (err/key-error! k))))

  (defn- swizzle-assoc
    [^Triple _ k v]
    (case k
      :s (Triple. v (.-p _) (.-o _) nil)
      :p (Triple. (.-s _) v (.-o _) nil)
      :o (Triple. (.-s _) (.-p _) v nil)
      0 (Triple. v (.-p _) (.-o _) nil)
      1 (Triple. (.-s _) v (.-o _) nil)
      2 (Triple. (.-s _) (.-p _) v nil)
      (swizzle-assoc* _ {\s 0 \p 1 \o 2} k v)))
#+END_SRC
*** Constructor
#+BEGIN_SRC clojure :noweb-ref triple
  (defn triple
    ([s p o] (Triple. s p o nil))
    ([t] (if (instance? Triple t) t (let [[s p o] t] (Triple. s p o nil)))))
#+END_SRC

** In-memory store

*** Type implementation
#+BEGIN_SRC clojure :noweb-ref memstore
  (defrecord PlainMemoryStore [spo pos ops size]
    PStatementAccess
    (add-statement
      [_ [s p o]]
      (let [s (get (find spo s) 0 s)
            p (get (find pos p) 0 p)
            o (get (find ops o) 0 o)]
        (if (-> spo (get s nil) (get p nil) (get o nil))
          _
          (PlainMemoryStore.
           (update-in spo [s p] d/set-conj o)
           (update-in pos [p o] d/set-conj s)
           (update-in ops [o p] d/set-conj s)
           (inc size)))))
    (add-bulk [_ statements]
      (loop [spo spo, pos pos, ops ops, size size, xs statements]
        (if xs
          (let [[s p o] (first xs)
                s (get (find spo s) 0 s)
                p (get (find pos p) 0 p)
                o (get (find ops o) 0 o)]
            (if (-> spo (get s nil) (get p nil) (get o nil))
              (recur spo pos ops size (next xs))
              (recur
               (update-in spo [s p] d/set-conj o)
               (update-in pos [p o] d/set-conj s)
               (update-in ops [o p] d/set-conj s)
               (inc size)
               (next xs))))
          (PlainMemoryStore. spo pos ops size))))
    (remove-statement [_ [s p o]]
      (if (-> spo (get s nil) (get p nil) (get o nil))
        (PlainMemoryStore.
         (remove-from-index spo s p o)
         (remove-from-index pos p o s)
         (remove-from-index ops o p s)
         (dec size))
        _))
    (remove-bulk [_ statements]
      (loop [spo spo, pos pos, ops ops, size size, xs statements]
        (if xs
          (let [[s p o] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get o nil))
              (recur
               (remove-from-index spo s p o)
               (remove-from-index pos p o s)
               (remove-from-index ops o p s)
               (dec size)
               (next xs))
              (recur spo pos ops size (next xs))))
          (PlainMemoryStore. spo pos ops size))))
    (update-statement [_ s1 s2]
      (add-statement (remove-statement _ s1) s2))
    (remove-subject [_ s]
      (remove-bulk _ (select _ s nil nil)))

    PModel
    (subject? [_ x]
      (if (spo x) x))
    (predicate? [_ x]
      (if (pos x) x))
    (object? [_ x]
      (if (ops x) x))
    (indexed? [_ x]
      (if (or (spo x) (pos x) (ops x)) x))
    (subjects [_] (keys spo))
    (predicates [_] (keys pos))
    (objects [_] (keys ops))
    (model-size [_] size)
    (select [_]
      (select _ nil nil nil))
    (select
      [_ s p o]
      (if s
        (if p
          (if o
            ;; s p o
            (let [t (triple s p o)]
              (if (-> spo (get s nil) (get p nil) (get o nil)) [t]))
            ;; s p nil
            (let [objects (-> spo (get s nil) (get p nil))]
              (if objects (map #(triple s p %) objects))))
          ;; s nil o / s nil nil
          (let [subjects (spo s)]
            (if subjects
              (select-seq subjects (fn [p] #(triple s p %)) (if o #(= o %))))))
        (if p
          (if o
            ;; nil p o
            (let [subjects (-> pos (get p nil) (get o nil))]
              (if subjects (map #(triple % p o) subjects)))
            ;; nil p nil
            (let [preds (pos p)]
              (if preds (select-seq preds (fn [o] #(triple % p o))))))
          (if o
            ;; nil nil o
            (let [objects (ops o)]
              (if objects (select-seq objects (fn [p] #(triple % p o)))))
            ;; nil nil nil
            (mapcat
             (fn [[s props]] (select-seq props (fn [p] #(triple s p %))))
             spo))))))
#+END_SRC

*** Alt implementation
#+BEGIN_SRC clojure :noweb-ref memstore
  (defrecord PlainMemoryStore2 [spo pos osp size]
    PStatementAccess
    (add-statement
      [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil))
        _
        (let [s (get (find spo s) 0 s)
              p (get (find pos p) 0 p)
              o (get (find osp o) 0 o)
              t (Triple. s p o nil)]
          (PlainMemoryStore2.
           (update-in spo [s p] d/set-conj t)
           (update-in pos [p o] d/set-conj t)
           (update-in osp [o s] d/set-conj t)
           (inc size)))))
    (add-bulk [_ statements]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs statements]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur changed? spo pos osp size (next xs))
              (let [s (get (find spo s) 0 s)
                    p (get (find pos p) 0 p)
                    o (get (find osp o) 0 o)
                    t (Triple. s p o nil)]
                (recur
                 true
                 (update-in spo [s p] d/set-conj t)
                 (update-in pos [p o] d/set-conj t)
                 (update-in osp [o s] d/set-conj t)
                 (inc size)
                 (next xs)))))
          (if changed?
            (PlainMemoryStore2. spo pos osp size)
            _))))
    (remove-statement [_ [s p o :as t]]
      (if (-> spo (get s nil) (get p nil) (get t nil))
        (PlainMemoryStore2.
         (remove-from-index spo s p t)
         (remove-from-index pos p o t)
         (remove-from-index osp o s t)
         (dec size))
        _))
    (remove-bulk [_ statements]
      (loop [changed? false, spo spo, pos pos, osp osp, size size, xs statements]
        (if xs
          (let [[s p o :as t] (first xs)]
            (if (-> spo (get s nil) (get p nil) (get t nil))
              (recur
               true
               (remove-from-index spo s p t)
               (remove-from-index pos p o t)
               (remove-from-index osp o s t)
               (dec size)
               (next xs))
              (recur changed? spo pos osp size (next xs))))
          (if changed?
            (PlainMemoryStore2. spo pos osp size)
            _))))
    (update-statement [_ s1 s2]
      (add-statement (remove-statement _ s1) s2))
    (remove-subject [_ s]
      (remove-bulk _ (select _ s nil nil)))

    PModel
    (subject? [_ x]
      (if (spo x) x))
    (predicate? [_ x]
      (if (pos x) x))
    (object? [_ x]
      (if (osp x) x))
    (indexed? [_ x]
      (if (or (spo x) (pos x) (osp x)) x))
    (subjects [_] (keys spo))
    (predicates [_] (keys pos))
    (objects [_] (keys osp))
    (model-size [_] size)
    (select [_]
      (select _ nil nil nil))
    (select
      [_ s p o]
      (if s
        (if p
          (if o
            ;; s p o
            (let [t (triple s p o)]
              (if (-> spo (get s nil) (get p nil) (get t nil)) [t]))
            ;; s p nil
            (-> spo (get s nil) (get p nil)))
          ;; s nil o / s nil nil
          (if o
            (-> osp (get o nil) (get s nil))
            (->> (spo s) vals (apply concat))))
        (if p
          (if o
            ;; nil p o
            (-> pos (get p nil) (get o nil))
            ;; nil p nil
            (->> (pos p) vals (apply concat)))
          (if o
            ;; nil nil o
            (->> (osp o) vals (apply concat))
            ;; nil nil nil
            (->> spo vals (mapcat vals) (apply concat)))))))
#+END_SRC

*** Constructors
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-store
    [& triples]
    (add-bulk (PlainMemoryStore. (hash-map) (hash-map) (hash-map) 0) triples))

  (defn plain-store-alt
    [& triples]
    (add-bulk (PlainMemoryStore2. (hash-map) (hash-map) (hash-map) 0) triples))
#+END_SRC

** Multi-store dataset

*** Type implementation
#+BEGIN_SRC clojure :noweb-ref dataset
  (defrecord PlainDataset [models]
    PStatementAccess
    (add-statement [_ s]
      (add-statement _ :default s))
    (add-statement [_ g s]
      (update-in _ [:models g] add-statement s))
    (add-bulk [_ statements]
      (add-bulk _ :default statements))
    (add-bulk [_ g statements]
      (update-in _ [:models g] add-bulk statements))
    (remove-statement [_ s]
      (remove-statement _ :default s))
    (remove-statement [_ g s]
      (update-in _ [:models g] remove-statement s))
    (remove-bulk [_ statements]
      (remove-bulk _ :default statements))
    (remove-bulk [_ g statements]
      (update-in _ [:models g] remove-bulk statements))
    (remove-subject [_ s]
      (remove-subject _ :default s))
    (remove-subject [_ g s]
      (update-in _ [:models g] remove-subject s))

    PModel
    (select [_]
      (select _ nil nil nil))
    (select [_ s p o]
      (mapcat #(select % s p o) (vals models)))
    (select [_ g s p o]
      (if-let [g (models g)] (select g s p o)))
    (subject? [_ x]
      (some #(subject? % x) (vals models)))
    (predicate? [_ x]
      (some #(predicate? % x) (vals models)))
    (object? [_ x]
      (some #(object? % x) (vals models)))
    (indexed? [_ x]
      (some #(indexed? % x) (vals models)))
    (subjects [_]
      (set (mapcat subjects (vals models))))
    (predicates [_]
      (set (mapcat predicates (vals models))))
    (objects [_]
      (set (mapcat objects (vals models))))
    (model-size [_]
      (reduce + (map model-size (vals models))))

    PDataset
    (update-model [_ id m]
      (assoc-in _ [:models id] m))
    (remove-model [_ id]
      (update-in _ [:models] dissoc id))
    (get-model [_ id]
      (models id)))
#+END_SRC

*** Constructor
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn plain-dataset
    [& {:as models}]
    (PlainDataset. (assoc models :default (plain-store))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/trio/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.trio.core
    (:refer-clojure :exclude [object? indexed?])
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]))

  <<protos>>

  <<helpers>>

  (declare swizzle swizzle-assoc)

  <<triple>>

  <<memstore>>

  <<dataset>>

  <<ctors>>
#+END_SRC
